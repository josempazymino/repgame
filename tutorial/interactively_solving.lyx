#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage[bottom]{footmisc}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams-bytype
theorems-ams-extended-bytype
theorems-sec-bytype
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "Interactively Solving Repeated Games. A Toolbox "
\pdf_author "Sebastian Kranz"
\pdf_subject "repeated games"
\pdf_keywords "repeated games, computing supergame payoffs, algorithm, optimal penal codes, monetary transfers, game theory, software, toolbox"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3.5cm
\topmargin 3cm
\rightmargin 3.5cm
\bottommargin 3cm
\headsep 0.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle headings
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Interactively Solving Repeated Games: A Toolbox
\begin_inset Newline newline
\end_inset

Version 0.2
\end_layout

\begin_layout Author
Sebastian Kranz
\begin_inset Foot
status open

\begin_layout Plain Layout
skranz@uni-bonn.de.
 I want to thank the Deutsche Forschungsgemeinschaft (DFG) through SFB-TR
 15 for financial support.
\end_layout

\end_inset


\end_layout

\begin_layout Address
\align center
University of Cologne
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Abstract
This paper shows how to use my free software toolbox 
\family typewriter
\emph on
repgames
\family default
\emph default
 for R to analyze infinitely repeated games.
 Based on the results of Goldluecke & Kranz (2012), the toolbox allows to
 compute the set of pure strategy public perfect equilibrium payoffs and
 to find optimal equilibrium strategies for all discount factors in repeated
 games with perfect or imperfect public monitoring and monetary transfers.
 This paper explores various examples, including variants of repeated public
 goods games and different variants of repeated oligopolies, like oligopolies
 with many firms, multi-market contact or imperfect monitoring of sales.
 The paper also explores repeated games with infrequent external auditing
 and games were players can secretly manipulate signals.
 On the one hand the examples shall illustrate how the toolbox can be used
 and how our algorithms work in practice.
 On the other hand, the examples may in themselves provide some interesting
 economic and game theoretic insights.
\end_layout

\begin_layout Abstract
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
A main goal of the theory of infinitely repeated games is to understand
 for different environments how and to which degree self-interested parties
 can sustain cooperative outcomes through repeated interaction.
 This tutorial describes a free software toolbox for R that allows to calculate
 optimal equilibria and the set of implementable payoffs for any discount
 factor in infinitely repeated games with imperfect or perfect monitoring
 monitoring that allow for monetary transfers.
 It is based on my joint paper with Susanne Goldlücke
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Susanne just recently married and may still be better known by her former
 name Susanne Ohlendorf
\end_layout

\end_inset

 (Goldlücke and Kranz, 2012) that develops and explains the underlying theoretic
al results.
 To understand how and why the software works and to interpret the results,
 I strongly recommend to have a look at our theoretical paper.
\end_layout

\begin_layout Standard
I believe that the presented toolbox can be quite helpful for economists
 and other social scientists who use game theoretic models to get a deeper
 understanding of many interesting social phenomena.
 Here are several situations, in which you may find the software useful:
\end_layout

\begin_layout Enumerate
You analyze a static game theoretic model of some economic phe-nomena and
 quickly want to check with some numerical examples the robustness of your
 predictions to repeated interactions (in particular, the robustness of
 your comparative statics).
\end_layout

\begin_layout Enumerate
Similarly, you may want to use the toolbox for robustness checks if you
 already analyze a repeated game but have considered only a particular class
 of strategies, like grim-trigger strategies.
\end_layout

\begin_layout Enumerate
You may want to check whether some particular class of equilibria you study
 are optimal or how far they are away from the boundary of optimal (pure
 strategy) equilibria.
 The toolbox only analyzes repeated games where monetary transfers are allowed,
 but the resulting payoff sets generate an upper bound to payoff sets of
 games where no monetary transfers are possible.
\end_layout

\begin_layout Enumerate
You can use the toolbox to develop and test conjectures about the structure
 of optimal equilibria in a particular repeated games, e.g.
 whether w.l.o.g.
 some symmetry constraints can be imposed.
 I try to illustrate this approach in several examples studied in this paper.
\end_layout

\begin_layout Enumerate
You want to design an experiment about repeated games (with monetary transfers)
 and want to quickly find the equilibrium payoff sets for different possible
 treatment configurations.
\end_layout

\begin_layout Enumerate
You may also consider the toolbox when teaching about repeated games, in
 particular if you think that students should not only learn math and economics,
 but should also acquire some programming skills.
 R is really a great software that is very popular among statisticians.
\end_layout

\begin_layout Standard
Besides the core functions that solve a repeated game using our algorithm,
 the software contains several additional tools, in particular for graphical
 analysis, that facilitate testing and interpretation of the results and
 the analysis of comparative statics.
 So far, the toolbox itself is not yet well documented (the the source code
 is often commented, however) so this paper is the main source of documentation.
\end_layout

\begin_layout Standard
The main goals of this paper are the following:
\end_layout

\begin_layout Enumerate
Describe how my software toolbox for R can be used.
\end_layout

\begin_layout Enumerate
Make some advertisement for our theoretical paper by showing how our theoretical
 results can be applied.
\end_layout

\begin_layout Enumerate
Analyze some non-trivial examples of repeated games.
 Show how comparative statics of the payoff sets can be performed and how
 optimal strategies look like.
 I hope that the game theoretic and economic insights from some examples
 are in themselves interesting for some readers.
 I am planning to extend several examples and analyze them in separate papers.
\begin_inset Foot
status open

\begin_layout Plain Layout
I know that it is not good style to put half-finished work that has almost
 no literature review to the web.
 Still, I chose do to so, since I wanted to include a lot of examples in
 this paper to illustrate various ways how our algorithm and the toolbox
 can be applied.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Section 2 explains how you can install the software.
 Afterward this paper is divided in two parts.
 Part I treats repeated games with perfect monitoring and Part II treats
 games with imperfect public monitoring.
 Each parts consist of different Sections that explain you how to use my
 toolbox (from basic to more advanced techniques) for different classes
 of games and at the same time contain some brief economic and game theoretic
 discussion of the results.
 In an appendix, I give some hints on debugging.
 (When I analyzed a new class of games, I nearly always made some mistakes
 in my code that specifies the stage game.
 I guess it is normal to need some debugging before everything runs fine).
 There are several exercises distributed across the different sections that
 invite you to explore my toolbox yourself.
\end_layout

\begin_layout Section
Installation of the software
\end_layout

\begin_layout Subsection
Installing R
\end_layout

\begin_layout Standard
My toolbox and all software you need to run it is open source and freely
 available for download.
\end_layout

\begin_layout Standard
First you have to install R, which is a very well developed software package
 for statistical and numerical computations with great graphic abilities,
 a very active community and a huge repository of contributed packages.
 To download the actual version of R visit the Comprehensive R Archive Network
 under
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://cran.r-project.org/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
On the CRAN you can also find many tutorials that introduce you to R.
\end_layout

\begin_layout Subsection
Installing the package under Windows 32 bit
\end_layout

\begin_layout Standard
My toolbox is an R package with name 
\shape italic
repgames
\shape default
.
 To run it also requires the packages 
\emph on
skUtils
\emph default
, 
\emph on
slam
\emph default
 and 
\emph on
glpkAPI
\emph default
.
 My own packages repgames and skUtil are not yet available on the CRAN.
 If you use Windows 32 bit, you can download the zip files of the two packages
 from my homepage:
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.wiwi.uni-bonn.de/kranz/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can install it in R by choosing the menu 
\begin_inset Quotes eld
\end_inset

packages
\begin_inset Quotes erd
\end_inset

 in your RGui and then the submenu 
\begin_inset Quotes eld
\end_inset

Install package from local zip files
\begin_inset Quotes erd
\end_inset

.
 Alternatively you can paste the current code, where you have to adjust
 the file path to the folder to which you have copied the zip files:
\end_layout

\begin_layout LyX-Code
install.packages("D:/libraries/skUtils.zip", repos = NULL)
\end_layout

\begin_layout LyX-Code
install.packages("D:/libraries/repgames.zip", repos = NULL)
\end_layout

\begin_layout Standard
Note: Use / instead of 
\backslash
 to specify file paths in R.
\end_layout

\begin_layout Standard
The two packages: 
\begin_inset Quotes eld
\end_inset

glpkAPI
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

slam
\begin_inset Quotes erd
\end_inset

 can be found on the CRAN.
 If you have internet access, you can simply type
\end_layout

\begin_layout LyX-Code
install.packages("slam")
\end_layout

\begin_layout LyX-Code
install.packages("glpkAPI")
\end_layout

\begin_layout Standard
which installs these packages directly from the CRAN.
 Before you can use the package repgames, you also have to load it in the
 actual R session.
 You can do this with the following command:
\end_layout

\begin_layout LyX-Code
library(repgames)
\end_layout

\begin_layout Standard
(You do not have to manually load the other packages).
\end_layout

\begin_layout Standard
If installation fails, please send me an email.
\end_layout

\begin_layout Subsection
Installing the package for a different operating system
\end_layout

\begin_layout Standard
If you want to use the package for a different operating system please send
 me an email.
\end_layout

\begin_layout Subsection
Running Examples
\end_layout

\begin_layout Standard
In the different Sections below you find a series of examples.
 One way to try them out, is to copy-and-paste them directly from this PDF
 file.
 Alternatively, you can download to .r files on my homepage that contain
 the examples of Parts I and II of this paper.
\end_layout

\begin_layout Subsection
Installing a text editor for R files
\end_layout

\begin_layout Standard
One convenient way to use R is to have some text editor, ideally with syntax
 highlighting for R files, and to copy-and-paste from the editor any sequence
 of R commands directly in the R console.
 Here is a list of editors for which syntax highlighting of R code is available:
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.sciviews.org/_rgui/projects/Editors.html
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I am a Windows User and like Notepad++ very much.
 It comes with syntax highlighting for R.
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://notepad-plus-plus.org/
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
About RStudio
\end_layout

\begin_layout Standard
RStudio is a great IDE for R with integrated editor that can be used as
 replacement of the default RGui.
 I use RStudio for most of my work with R and generally would recommend
 to every beginner.
 
\end_layout

\begin_layout Standard
I would not recommend it for my packacke repgames, though.
 The reason is that the current version of RStudio (0.95) does not update
 plots during program execution on my computer.
 For most work that is not a big issue, but when solving longer models in
 the repgames package I use a lot of dynamic plots that give the user some
 impression what is going on.
 In the moment, this does not really work under RStudio.
 Thus, so far, I would recommend to use the default RGui when working with
 the repgames package.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Perfect Monitoring
\end_layout

\begin_layout Section
A Simple Cournot Game
\begin_inset CommandInset label
LatexCommand label
name "sec:Simple-Cournot-Game"

\end_inset


\end_layout

\begin_layout Subsection
Initializing the game
\end_layout

\begin_layout Standard
As first example, let us consider the simple Cournot game from Abreu (1988)
 that is manually solved in Section 3 of Goldluecke & Kranz (2010).
 The payoff matrix of the stage game is given by
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Firm 2
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
L
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
M
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
H
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
L
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
10,10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
3,15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
0,7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Firm 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
M
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
15,3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
7,7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
-4,5  
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
H
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
7,0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
5,-4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
-15,-15
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
We assume that every period consists of 3 stages: an ex-ante payment stage,
 an action stage, and an ex-post payment stage.
 In the payment stages the players can simultaneously conduct monetary transfers
 to each other and in the action stage they play the simultaneous move stage
 game specified above.
 We also allow for money burning (or equivalently for transfers to a non-involve
d third party).
 Payoffs are additive in money and stage game payoffs and players are risk-neutr
al.
 Payoffs in future periods are discounted by a discount factor 
\begin_inset Formula $\delta\in[0,1)$
\end_inset

 and there is no discounting between the different stages within a period.
 For the moment, we assume that monitoring is perfect, i.e.
 all players perfectly observe all past action profiles.
\end_layout

\begin_layout Standard
I describe now how to initialize and solve the game using the 
\family typewriter
repgame
\family default
 package and R.
 First, we have to initialize the payoff matrix for player 1 and 2:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=FALSE, eval=TRUE, echo=FALSE, inline=FALSE>>=
\end_layout

\begin_layout Plain Layout

#render_sweave()
\end_layout

\begin_layout Plain Layout

#knit_theme$set("edit-msvs2008")
\end_layout

\begin_layout Plain Layout

#knit_theme$set("edit-vim")
\end_layout

\begin_layout Plain Layout

#knit_theme$set("edit-emacs")
\end_layout

\begin_layout Plain Layout

#knit_theme$set("edit-xcode")
\end_layout

\begin_layout Plain Layout

knit_theme$set("mytheme")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE>>=
\end_layout

\begin_layout Plain Layout

# Define Payoff Matrices for player 1 and 2
\end_layout

\begin_layout Plain Layout

              #L #M  #H
\end_layout

\begin_layout Plain Layout

g1 = rbind(c( 10, 3, 0),    # L
\end_layout

\begin_layout Plain Layout

           c( 15, 7, -4),   # M
\end_layout

\begin_layout Plain Layout

           c(  7, 5,-15))   # H
\end_layout

\begin_layout Plain Layout

g2 = t(g1)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can simply copy and paste the code above into the RGui.
 To get help on an function in R simply type 
\family typewriter
?functionname
\family default
, e.g.
 
\family typewriter
?rbind.

\family default
 To look at a variable, you simply have to type its name into the command
 screen, e.g.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE>>=
\end_layout

\begin_layout Plain Layout

g2
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that in this PDF file, R output is typically commented out with ##
 before each output line.
 This is done to make it easier to copy and paste code into R.
 We now load the library and initialize the game:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=FALSE, eval=TRUE, echo=TRUE>>=
\end_layout

\begin_layout Plain Layout

# Load package repgames
\end_layout

\begin_layout Plain Layout

library(repgames,warn.conflicts=FALSE)
\end_layout

\begin_layout Plain Layout

# Initialize the model of the repeated game
\end_layout

\begin_layout Plain Layout

m = init.game(g1=g1,g2=g2,lab.ai=c("L","M","H"),
\end_layout

\begin_layout Plain Layout

    name="Simple Cournot Game", symmetric=FALSE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ideally, you could get detailed information about the function init.game
 by typing 
\family typewriter
?init.game
\family default
.
 Practically, I have not yet written helpfiles for my toolbox.
 So most information is contained in this paper.
 While at some point of time the documentation hopefully extends, the reader
 interested in more details should look at the source code, which is partially
 commented.
 
\end_layout

\begin_layout Standard
Anyhow, the function 
\family typewriter
init.game
\family default
 sets up basic information about the stage game and converts it into a format
 that is suitable for further calculation.
 If you wonder, why I set 
\family typewriter
symmetric=FALSE
\family default
, read this footnote.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
If the stage game is symmetric and the flag 
\family typewriter
symmetric=TRUE
\family default
 is set, the algorithm works a bit faster, since it only calculates optimal
 punishment profiles for player 1.
 But even though the game is symmetric, you can always specify to solve
 it without taken advantages of knowing that the game is symmetric.
 So why did I chose the later option by setting the flag 
\family typewriter
symmetric=FALSE
\family default
? Nothing important, just when looking at 
\family typewriter
m$opt.mat
\family default
 (see below) the label of the action plans then contains a punishment profile
 for every player not only player 1.
 I found this nicer for an initial example.
\end_layout

\end_inset

 All calculated objects are stored in the variable 
\family typewriter
m
\family default
.
 Type 
\family typewriter
m
\family default
 to have a look at its content.
 You can access particular elements of 
\family typewriter
m
\family default
 by the 
\family typewriter
$ 
\family default
operator.
 For example, type 
\family typewriter
m$g
\family default
 in the R command line:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE>>=
\end_layout

\begin_layout Plain Layout

m$g
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout LyX-Code
 m$g
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
    [,1] [,2]
\end_layout

\begin_layout LyX-Code
L|L   10   10
\end_layout

\begin_layout LyX-Code
L|M    3   15
\end_layout

\begin_layout LyX-Code
L|H    0    7
\end_layout

\begin_layout LyX-Code
M|L   15    3
\end_layout

\begin_layout LyX-Code
M|M    7    7
\end_layout

\begin_layout LyX-Code
M|H   -4    5
\end_layout

\begin_layout LyX-Code
H|L    7    0
\end_layout

\begin_layout LyX-Code
H|M    5   -4
\end_layout

\begin_layout LyX-Code
H|H  -15  -15
\end_layout

\end_inset

The variable contains a matrix that stores the payoffs of the stage game:
 every row corresponds to an action profile and every column to a particular
 player.
 This is the standard format my package uses to store and process payoffs.
 There is a fixed scheme how action profiles are ordered that you probably
 can induce from the example.
 Action profiles are internally indexed by their row number in the matrix
 
\family typewriter
m$g
\family default
.
 R has the convenient feature that rows and columns of a matrix can be accessed
 by specified names.
 For example,
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE>>=
\end_layout

\begin_layout Plain Layout

m$g["H|M",]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

% [1]  5 -4
\end_layout

\end_inset


\end_layout

\begin_layout Standard
yields the payoff vector associated with the action profile 
\begin_inset Formula $(H,M)$
\end_inset

.
 You would get the same result by typing 
\family typewriter
m$g[8,]
\family default
.
 When we called, 
\family typewriter
init.model
\family default
 we provided with the parameter 
\family typewriter
lab.ai=c("L","M","H")
\family default
, a vector of action names and by default the names of action profiles have
 the structure 
\begin_inset Formula $a_{1}|a_{2}|...|a_{n}$
\end_inset

.
 Providing short sensible action names, is helpful when using the toolbox.
\end_layout

\begin_layout Standard
The next example, lists all pure strategy Nash equilibria of the stage game:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE>>=
\end_layout

\begin_layout Plain Layout

m$nash
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

% M|M 
\end_layout

\begin_layout Plain Layout

%   5 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The variable 
\family typewriter
m$nash
\family default
 is a numerical vector giving the index of the action profiles that are
 Nash equilibria.
 The first row is simply the named assigned to this profile.
\end_layout

\begin_layout Subsection
Solving and plotting the game
\end_layout

\begin_layout Standard
Let us now solve the repeated game.
 We do this by pasting the following lines:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE>>=
\end_layout

\begin_layout Plain Layout

# Solve the game
\end_layout

\begin_layout Plain Layout

m = solve.game(m, keep.only.opt.rows=TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I will explain further below the meaning of the parameter 
\family typewriter
keep.only.opt.rows.

\family default
 If you take again a look at 
\family typewriter
m
\family default
, you will see that several new elements are added.
 The relevant information about the solution is stored in the matrix 
\family typewriter
m$opt.mat
\family default
.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE>>=
\end_layout

\begin_layout Plain Layout

# Show matrix with critical delta, optimal action plans and payoffs
\end_layout

\begin_layout Plain Layout

m$opt.mat
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout LyX-Code
                      delta  L Ue  V v1 v2 ae a1 a2   r UV opt
\end_layout

\begin_layout LyX-Code
(M|M),(M|M),(M|M) 0.0000000  0 14 14  7  7  5  5  5 Inf  0   1
\end_layout

\begin_layout LyX-Code
(L|M),(M|H),(H|M) 0.2500000  6 18  0  0  0  2  6  8   3 18   1
\end_layout

\begin_layout LyX-Code
(L|L),(M|H),(H|M) 0.3333333 10 20  0  0  0  1  6  8   2 20   1
\end_layout

\end_inset

Each row characterizes an optimal action plan and payoff set for a certain
 interval of discount factors.
 For an explanation of what are optimal action plans and other important
 concepts for understanding the details of the solution, have a look at
 our theoretical paper (Goldluecke & Kranz, 2010).
\end_layout

\begin_layout Standard
The name of every row labels the optimal action plan 
\begin_inset Formula $(a^{e},a^{1},a^{2})$
\end_inset

 and the indices of the action profiles are given in the corresponding later
 columns.
 The action profile 
\begin_inset Formula $a^{e}$
\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
is
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 played in every period on the equilibrium path.
 The punishment profiles 
\begin_inset Formula $a^{1}$
\end_inset

 and 
\begin_inset Formula $a^{2}$
\end_inset

 for player 1 and 2, respectively, would be played for one period if a player
 once unilaterally defected from a required payment.
 The column 
\family typewriter
delta
\family default
 denotes the lowest discount factor, for which the action plan is optimal
 and 
\family typewriter
r
\family default
 is the corresponding maximal discount rate.
 Column 
\family typewriter
Ue
\family default
 denotes the maximal joint payoff and 
\family typewriter
v1
\family default
 and 
\family typewriter
v2
\family default
 denote the punishment payoffs of player 1 and 2.
 
\family typewriter
V
\family default
 is simply the sum of all players' punishment payoffs.
 
\end_layout

\begin_layout Standard
The variables 
\family typewriter
L
\family default
 denotes the highest liquidity requirement of all action profiles in the
 action plan.
 The liquidity requirement of an action profile (or action plan) plays a
 crucial role in our algorithm.
 If you just want to apply the software, you can ignore it, but I would
 recommend to look at our paper to learn more about it.
 Briefly said, to implement an action profile in a static problem with enforceab
le payments and liquidity constraints, the sum of all players liquidity
 must be at least equal to the liquidity requirement of the action profile.
 
\end_layout

\begin_layout Standard
The set of (pure strategy public perfect) equilibrium payoffs corresponding
 to a particular row is given by 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left\{ (u_{1},...,u_{n})\text{ }|\text{ }\sum_{i=1}^{n}u_{i}\leq U^{e}\text{ and }u_{i}\geq v_{i}\text{ for all }i\right\} .
\]

\end_inset


\end_layout

\begin_layout Standard
For example, if the discount factor satisfies 
\begin_inset Formula $\delta\in[\frac{1}{4},\frac{1}{3}]$
\end_inset

(well, as usual 0.3333333 actually means 
\begin_inset Formula $\frac{1}{3}$
\end_inset

),
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 the set of equilibrium payoffs is given by every payoff vector 
\begin_inset Formula $\ensuremath{u\in\mathbb{R}^{2}}$
\end_inset

 with
\begin_inset Formula $\sum_{i=1}^{n}u_{i}\leq18$
\end_inset

 and 
\begin_inset Formula $u_{i}\geq0$
\end_inset

.
 On the equilibrium path, players infinitely often repeat the asymmetric
 equilibrium state action profile 
\begin_inset Formula $a^{e}=(L,M)$
\end_inset

.
 The punishment profiles of player 1 and 2 are 
\begin_inset Formula $\mbox{\ensuremath{a^{1}=(M,H)}}$
\end_inset

and
\begin_inset Formula $\mbox{ }a^{2}=(H,M)$
\end_inset

, respectively.
 
\end_layout

\begin_layout Standard
To plot maximal joint equilibrium payoffs 
\begin_inset Formula $U^{e}$
\end_inset

 and lowest joint and payoffs for all discount factors, we can type
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot_pd1, cache=TRUE, eval=FALSE, echo=TRUE>>=
\end_layout

\begin_layout Plain Layout

plot(m,xvar="delta",yvar=c("Ue","V"))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where the parameters should be self-explanatory.
 The result is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:payoffs simple cournot"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename abreu_payoffs.eps
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Maximal payoffs and sum of punishment payoffs of the repeated simple Cournot
 game (with side payments) for all discount factors.
\begin_inset CommandInset label
LatexCommand label
name "fig:payoffs simple cournot"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
By default the plot shows the joint equilibrium and punishment payoffs as
 function of the discount factor, but the plot can be customized to show
 other payoffs.
 The dotted horizontal lines indicate the maximal joint payoffs and joint
 stage game payoffs.
 For repeated games with perfect monitoring (and finite action space and
 monetary transfers) the maximal implementable joint payoffs and lowest
 punishment payoffs are always step functions.
 Each step corresponds to another optimal action plan, i.e.
 to another row in 
\family typewriter
m$opt.mat
\family default
.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\emph on
Identifying optimal action plans by clicking on the plot
\end_layout

\begin_layout Plain Layout
Sometimes you will encounter some plot of payoffs and would quickly like
 to know about the optimal action plan that corresponds to some part of
 the plot.
 Insert the following code:
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<pd_identify, cache=TRUE, eval=FALSE, echo=TRUE>>=
\end_layout

\begin_layout Plain Layout

plot(m,xvar="delta",yvar=c("Ue","V"), identify=TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The flag 
\family typewriter
identify=TRUE 
\family default
makes the plot interactive, i.e.
 you can left-click on the plot to get more information.
 I clicked on the second step of the Ue function, at the position indicated
 by the dotted grey vertical line in the figure below.
\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename abreu_payoffs_interactive.eps
	lyxscale 70
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
When clicking, the R console prints out the following information about
 the optimal action plan and payoffs for the selected level of 
\begin_inset Formula $\delta$
\end_inset

:
\end_layout

\begin_layout LyX-Code
"delta = 0.297" 
\end_layout

\begin_layout LyX-Code
                  delta L Ue V v1 v2 ae a1 a2 r   UV opt 
\end_layout

\begin_layout LyX-Code
(L|M),(M|H),(H|M) 0.297 6 18 0 0 0 2 6 8 2.367003 18 1 
\end_layout

\begin_layout Plain Layout
You can click on as many points as you like.
 To leave the interactive mode, you have to make a right-click on the plot
 and select the menu point stop.
 Alternatively, you can click on the red stop button in the toolbar of the
 RGui.
 I incorporated some interaction for most of the plotting functions you
 will encounter further below in this tutorial (e.g.
 
\family typewriter
levelplot.payoff.compstat 
\family default
or 
\family typewriter
plot.compare.models
\family default
).
 Just try out what happens if you call them with the parameter 
\family typewriter
identify=TRUE.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, let us see what happens if we call 
\family typewriter
solve.game
\family default
 and set the flag 
\family typewriter
keep.only.opt.rows = FALSE:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE>>=
\end_layout

\begin_layout Plain Layout

m = solve.game(m, keep.only.opt.rows=FALSE)
\end_layout

\begin_layout Plain Layout

m$opt.mat
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
                      delta  L Ue  V v1 v2 ae a1 a2   r UV opt
\end_layout

\begin_layout LyX-Code
(M|M),(M|M),(M|M) 0.0000000  0 14 14  7  7  5  5  5 Inf  0   1
\end_layout

\begin_layout LyX-Code
(L|M),(M|M),(M|M) 0.5000000  4 18 14  7  7  2  5  5   1  4   0
\end_layout

\begin_layout LyX-Code
(L|M),(M|H),(H|M) 0.2500000  6 18  0  0  0  2  6  8   3 18   1
\end_layout

\begin_layout LyX-Code
(L|L),(M|H),(H|M) 0.3333333 10 20  0  0  0  1  6  8   2 20   1
\end_layout

\end_inset

We find that 
\family typewriter
m$opt.mat
\family default
 contains an additional 2nd row, for which the last column 
\begin_inset Quotes eld
\end_inset

opt
\begin_inset Quotes erd
\end_inset

 is set to 0.
 The second row corresponds to an action plan that optimizes all the static
 problems given total liquidity 
\begin_inset Formula $L=4$
\end_inset

, but that is not an optimal action plan for any discount factor.
 By default, we have the option 
\family typewriter
keep.only.opt.rows=FALSE,
\family default
 i.e.
 rows like the 2nd row will be kept.
\end_layout

\begin_layout Subsection
Comparing optimal equilibria with equilibria in grim-trigger strategies
\end_layout

\begin_layout Standard
In many applied theoretical papers, repeated games are only analyzed by
 restricting attention to so called grim-trigger strategies.
 I implemented a function to calculate the payoff sets under grim-trigger
 equilibria.
 More precisely, I mean the payoffs that can be implemented by the class
 of equilibria that do not use monetary transfers and have a constant outcome
 path in the sense that a single action profile will be played in every
 period on the equilibrium path; any unilateral deviation of some player
 
\begin_inset Formula $i$
\end_inset

 is punished by reverting forever after to the worst Nash equilibrium of
 player 
\begin_inset Formula $i$
\end_inset

.
 
\end_layout

\begin_layout Standard
The following code solves the game by using only grim-trigger strategies:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE,tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# Solve the game with grim-trigger strategies
\end_layout

\begin_layout Plain Layout

m.gt = set.to.grim.trigger(m)
\end_layout

\begin_layout Plain Layout

m.gt = solve.game(m.gt)
\end_layout

\begin_layout Plain Layout

m.gt$opt.mat
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout LyX-Code
   delta Ue  V   r ae delta1 delta2 g1 g2 L1 L2 L opt
\end_layout

\begin_layout LyX-Code
M|M 0.000 14 14 Inf  5  0.000  0.000  7  7  0  0 4   1
\end_layout

\begin_layout LyX-Code
L|L 0.625 20 14 0.6  1  0.625  0.625 10 10  5  5 5   1
\end_layout

\end_inset

The structure of the matrix is similar to that of
\family typewriter
 m$pm.opt.mat
\family default
.
 We find that when using only grim-trigger strategies the critical discount
 factor to sustain the fully collusive outcome 
\begin_inset Formula $(L,L)$
\end_inset

 is much larger than for optimal strategy profiles: 
\begin_inset Formula $0.625=\frac{5}{8}$
\end_inset

 compared to 
\begin_inset Formula $\frac{1}{3}$
\end_inset

.
 Playing the partial collusive outcome 
\begin_inset Formula $(L,M)$
\end_inset

 on the equilibrium path is never optimal in the class of grim-trigger equilibri
a.
 We can also graphically compare the two models by typing:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE,tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

plot.compare.models(m,m.gt,xvar="delta",yvar="Ue",
\end_layout

\begin_layout Plain Layout

  legend.pos="topleft",m1.name = "opt", m2.name="grim")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The resulting output is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:opt vs grim"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename abreu_opt_vs_grim.eps
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Comparison of payoffs under optimal equilibria and grim-trigger equilibria
\begin_inset CommandInset label
LatexCommand label
name "fig:opt vs grim"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Public Goods Games
\end_layout

\begin_layout Subsection
Parametrizing two player public goods games
\end_layout

\begin_layout Standard
For a deeper analysis of some class of games, it is helpful to write functions
 that automatically initialize these games with a provided list of parameters.
 I want to illustrate an implementation with a simple two player public
 goods game.
 Each player 
\begin_inset Formula $i$
\end_inset

 can choose a contribution level 
\begin_inset Formula $x_{i}\in X=\{0,1,...,x_{max}\}$
\end_inset

.
 Stage game payoffs shall be given by
\begin_inset Formula 
\begin{equation}
g_{i}(x_{i},x_{j})=\frac{x_{1}+x_{2}}{2}-k_{i}x_{i}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $k_{i}\in$
\end_inset


\begin_inset Formula $[\frac{1}{2},1]$
\end_inset

 is a cost parameter that measures the marginal production cost of player
 
\begin_inset Formula $i$
\end_inset

 for each contributed unit.
 The following R code generates a function that initializes, solves and
 plots a parametrized public goods game in this class.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE,tidy=FALSE,size='footnotesize'>>=
\end_layout

\begin_layout Plain Layout

public.goods.game = function(X, k1,k2=k1) {
\end_layout

\begin_layout Plain Layout

  # Two lines that are useful for debugging 
\end_layout

\begin_layout Plain Layout

  # (see hints below)
\end_layout

\begin_layout Plain Layout

  store.objects("public.goods.game")
\end_layout

\begin_layout Plain Layout

  # restore.objects("public.goods.game")         
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  # Initialize matrices of players contributions
\end_layout

\begin_layout Plain Layout

  x1m = matrix(X,NROW(X),NROW(X),byrow=FALSE) 
\end_layout

\begin_layout Plain Layout

  x2m = matrix(X,NROW(X),NROW(X),byrow=TRUE)                      
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  # Calculate payoff matrices for each player
\end_layout

\begin_layout Plain Layout

  g1 = (x1m+x2m)/2 - k1*x1m         
\end_layout

\begin_layout Plain Layout

  g2 = (x1m+x2m)/2 - k2*x2m
\end_layout

\begin_layout Plain Layout

		 
\end_layout

\begin_layout Plain Layout

  # Give the game a name
\end_layout

\begin_layout Plain Layout

  name = paste("Public Goods Game k1=", k1, " k2=", k2, sep="")
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

  # Initialize the game	    
\end_layout

\begin_layout Plain Layout

  m = init.game(n=2,g1=g1,g2=g2,name=name, lab.ai=X)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  # Solve and plot the model 
\end_layout

\begin_layout Plain Layout

  m = solve.game(m, keep.only.opt.rows=TRUE)
\end_layout

\begin_layout Plain Layout

  plot(m)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  return(m)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsubsection*

\emph on
Hints on R Programming
\end_layout

\begin_layout Plain Layout
1.
 
\emph on
Avoid loops and apply functions on vector or matrices whenever possible
\emph default
 
\end_layout

\begin_layout Plain Layout
R is a great language, but awfully slow when it comes to loops.
 You should therefore always try to apply calculations on whole matrices
 or vectors whenever possible (by default R carries out all arithmetic operation
s element-wise).
 Creating some additional matrices like x1m and x2m, to facilitate calculations
 on matrices goes very quick in comparison.
\end_layout

\begin_layout Plain Layout
2.
 
\emph on
How can you follow step by step what my function does?
\end_layout

\begin_layout Plain Layout
You might want to understand step by step how my code within the function
 works.
 One method is to use the default debugger of R accessible e.g.
 through the 
\family typewriter
browser()
\family default
 function.
 Since R is an interpreter you can, alternatively, simply paste the lines
 within the function into the R command screen and look at each step at
 the variables or plot them.
 The only problem is that the arguments of the function call, i.e.
 
\family typewriter
X, k1,k2, name
\family default
, will not be properly assigned in the global environment.
 To solve this problem conveniently, I call within my function 
\family typewriter
store.objects()
\family default
, which stores a copy of all local objects in a global list under the provided
 name.
 The function 
\family typewriter
restore.objects
\family default
 can be used the stored local objects from the last function call into the
 global environment.
 The following code explains, how I use this in practice:
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# 1.
 Call the function with some parameters of interest
\end_layout

\begin_layout Plain Layout

m = public.goods.game(X=0:2,k1=0.75)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# 2.
 Copy and paste the function code up to the
\end_layout

\begin_layout Plain Layout

#    point of interest, starting with the
\end_layout

\begin_layout Plain Layout

#    uncommented call to restore.object
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

restore.objects("public.goods.game")         
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Initialize matrices of players contributions
\end_layout

\begin_layout Plain Layout

x1m= matrix(X,NROW(X),NROW(X),byrow=!TRUE) 
\end_layout

\begin_layout Plain Layout

x2m = t(x1m)                      
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

# Calculate payoff matrices for each player
\end_layout

\begin_layout Plain Layout

g1 = (x1m+x2m)/2 - k1*x1m         
\end_layout

\begin_layout Plain Layout

g2 = (x1m+x2m)/2 - k2*x2m
\end_layout

\begin_layout Plain Layout

@ 
\end_layout

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# 3.
 Inspect the variables of interest,e.g.
\end_layout

\begin_layout Plain Layout

#    print or plot them.
\end_layout

\begin_layout Plain Layout

# How do x1m and x2m look like?
\end_layout

\begin_layout Plain Layout

x1m
\end_layout

\begin_layout Plain Layout

x2m
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Of course, my method is a bit untidy in so far that I simply copy a lot
 of variables into the global environment, which perhaps may override some
 important global variables.
 However, in practice this has never been a big problem when I developed
 my toolbox and I found this way of debugging quite helpful to find where
 exactly something in my code went wrong.
\end_layout

\begin_layout Plain Layout

\emph on
3.
 A note for more advanced programmers
\end_layout

\begin_layout Plain Layout
If the passed arguments are large, you might think that the function 
\family typewriter
\emph on
store.objects
\family default
\emph default
 must be either quite time consuming, if it makes copies of each arguments,
 or flawed, if it just stores a pointer.
 In fact, it is not flawed but still relatively quick, since R uses a cool
 lazy evaluation feature.
 For the user, variables never behave like pointers, but internally R only
 creates a pointer when some object is copied.
 R makes an actual copy of an object only when it is changed.
 To understand what I mean, consider the following example:
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE,tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

x = numeric(10^8)          # Line 1
\end_layout

\begin_layout Plain Layout

y=x                        # Line 2
\end_layout

\begin_layout Plain Layout

y[1]=2                     # Line 3
\end_layout

\begin_layout Plain Layout

y[1]=3                     # Line 4
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

c(x[1],y[1])               # Show start of both vectors
\end_layout

\begin_layout Plain Layout

rm(x,y)                    # Removes x and y from memory
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The first line creates a big vector filled with zeros and takes some time
 (if the vector is large enough compared to your computing power).
 The second line copies the vector to the variable y.
 The third and fourth line just change the first element of y.
 On first thought, one would suspect that line 3 and 4 are super fast while
 line 2 may take some time.
 In fact, however, line 2 and 4 are super fast, while line 3 takes some
 time.
 You may even get an out of memory error in line 3.
 That is because the vector is physically copied only in line 3.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us us solve the public goods game with the parameters 
\begin_inset Formula $X=\{0,1,...,10\}$
\end_inset

 and identical production cost of both players of 
\begin_inset Formula $k_{1}=k_{2}=\frac{3}{4}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE,fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

m = public.goods.game(X=1:10,k1=0.75,k2=0.75)
\end_layout

\begin_layout Plain Layout

m$opt.mat
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\emph on
\color blue
\begin_inset Note Note
status collapsed

\begin_layout LyX-Code

\emph on
   
\emph default
                   delta L Ue V v1 v2  ae a1 a2   r UV opt
\end_layout

\begin_layout LyX-Code
  (0|0),(0|0),(0|0)     0.0 0  0 0  0  0   1  1  1 Inf  0   1
\end_layout

\begin_layout LyX-Code
  (10|10),(0|0),(0|0)   0.5 5  5 0  0  0 121  1  1   1  5   1 
\emph on
\color blue
  
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We find that for all discount factors 
\begin_inset Formula $\delta\geq\frac{1}{2}$
\end_inset

, maximal contributions 
\begin_inset Formula $(10,10)$
\end_inset

 can be sustained and for lower discount factors the only equilibrium is
 the Nash equilibrium of the stage game.
 Since the Nash equilibrium gives every player his min-max payoff of the
 stage game, it is always an optimal punishment profile.
 Given this fact and the symmetric structure, one might suspect that grim-trigge
r strategies can sustain full contribution for the same range of discount
 factor.
 You can verify this conjecture either by doing the math in your head or
 calculating the critical discount factor under grim-trigger strategies
 in the way explained in Section 3.3.
 Below, in Exercise 1, you are asked to investigate the more interesting
 case that the two players have different production costs.
\end_layout

\begin_layout Subsection
Analyzing comparative statics
\begin_inset CommandInset label
LatexCommand label
name "sub:Analysing-comparative-statics"

\end_inset


\end_layout

\begin_layout Subsubsection
Symmetric costs
\end_layout

\begin_layout Standard
Before we come to the exercises, I want to illustrate how one can graphically
 analyze the comparative statics of the equilibrium set with respect to
 some parameter of the stage game, like the marginal production costs.
 The following little piece of code solves the model for a grid of different
 marginal production costs between 
\begin_inset Formula $\frac{1}{2}$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

 and stores the solved models in the variable 
\family typewriter
m.list
\family default
.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE,fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

pg.games = Vectorize(public.goods.game,
\end_layout

\begin_layout Plain Layout

           vectorize.args = c("k1","k2"),SIMPLIFY=FALSE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

k.seq = seq(0.5,1,by = 0.01)
\end_layout

\begin_layout Plain Layout

m.list = pg.games(X=0:10,k1=k.seq,k2=k.seq)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first line transforms the function 
\family typewriter
public.goods.game
\family default
 so that it can also take vector arguments for the cost parameters.
 It works as if you wold manually go through a loop and repeatedly apply
 the function 
\family typewriter
public.goods.game
\family default
 for every element of the vector and store the results in a list.
 The next row specifies the vector of the different production costs that
 we are interested in.
 Here, we consider a grid with step size 0.01.
 The next line, calls the function and stores the resulting solved models
 in the variable 
\family typewriter
m.list
\family default
 which is of the very flexible R type 
\family typewriter
list
\family default
..
 To access, say the 50th solved model, simply type 
\family typewriter
m.list[[50]]
\family default
.
 During the execution of the code, you will see a little movie on the plot
 screen, since the function public.goods.game plots the payoffs for every
 solved model.
 
\end_layout

\begin_layout Standard
You can tell R to record all plots.
 To do this, click on the graphic window, then select from the menu 
\begin_inset Quotes eld
\end_inset

history
\begin_inset Quotes erd
\end_inset

 the element 
\begin_inset Quotes eld
\end_inset

Recording
\begin_inset Quotes erd
\end_inset

.
 From now on all future plots will be recorded.
 You can then go through the different plots with your page-up and page-down
 keys and investigate comparative statics in a flip-book fashion (try it
 out!).
\end_layout

\begin_layout Standard
If you paste the following line of code, you see a levelplot of maximal
 joint equilibrium payoffs as a function of the discount factor and the
 marginal production cost:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none", tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

mat = levelplot.payoff.compstat(m.list, par = k.seq,
\end_layout

\begin_layout Plain Layout

  xvar = "k", yvar = "delta", payoff.var="Ue", 
\end_layout

\begin_layout Plain Layout

  delta = seq(0,1,by=0.01), col.scheme = "grey")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
levelplot.payoff.compstat
\family default
 returns a matrix with the joint equilibrium payoffs for every combination
 of the specified levels of 
\family typewriter
k
\family default
 and 
\family typewriter
delta
\family default
.
 The resulting plot is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:compstat_pg_delta"

\end_inset

:
\begin_inset Foot
status open

\begin_layout Plain Layout
The figures level plots will actually look better if you paste the code
 yourself.
 I have not yet found out how to get rid of these annoying white lines in
 the plot and legend when converting the levelplots into eps files.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pg_contour.eps
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Comparative statics of maximal joint payoffs w.r.t.
 
\begin_inset Formula $\delta$
\end_inset

 and symmetric production costs 
\begin_inset Formula $k$
\end_inset

.
 Darker points correspond to lower joint payoffs 
\begin_inset Formula $U^{e}$
\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "fig:compstat_pg_delta"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We find from the plot that the critical discount factor for which positive
 contribution levels can be sustained increases linearly in the production
 costs.
\end_layout

\begin_layout Subsubsection
Asymmetric Costs
\end_layout

\begin_layout Standard
Let us now investigate asymmetric public goods games where the players have
 different production costs.
 Instead of immediately solving the model, you might find it more fun to
 make some quick conjectures of how the solutions will look like.
 For example, you could guess an answer to the following questions:
\end_layout

\begin_layout Itemize
Will players still either produce 0 or 10, or can intermediate production
 levels become optimal?
\end_layout

\begin_layout Itemize
Will grim-trigger equilibria still be able to implement the maximal joint
 payoffs for every discount factor or can optimal stationary equilibria
 with side payments implement strictly larger joint payoffs for some discount
 factors? 
\end_layout

\begin_layout Itemize
Does the maximal payoff only depend on the sum of production costs 
\begin_inset Formula $k_{1}+k_{2}$
\end_inset

, or only on the minimum production costs 
\begin_inset Formula $min(k_{1},k_{2})$
\end_inset

, or is the structure more complicated?
\end_layout

\begin_layout Standard
You can then check whether the computed examples are consistent with your
 guesses or provide counter examples.
 To look at a single example, say 
\begin_inset Formula $k_{1}=0.6$
\end_inset

 and 
\begin_inset Formula $k_{2}=0.7$
\end_inset

, you can type: 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

m = public.goods.game(X=1:10,k1=0.6,k2=0.7)
\end_layout

\begin_layout Plain Layout

m.grim = solve.game(set.to.grim.trigger(m))
\end_layout

\begin_layout Plain Layout

m.grim$opt.mat
\end_layout

\begin_layout Plain Layout

m$opt.mat
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
From the results you will already get some answers to the first two questions
 above and may generally gain a better intuition of the structure of the
 game.
 The main factors that drive the results is that, given an identical contributio
n level, the low cost player has lower incentives to deviate than the high
 cost player.
 Furthermore, under optimal equilibria with monetary transfers, the high
 cost player can pay money to the low cost player in return for high contributio
n levels.
\end_layout

\begin_layout Standard
We can also perform graphical comparative statics with respect to the two
 cost parameters.
 The following code produces the levelplot shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:compstat_pg_k1k2"

\end_inset

: 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none", tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Generate grid of k1 and k2 combinations between 0.5 and 1
\end_layout

\begin_layout Plain Layout

k.seq = seq(0.5,1,by = 0.02)
\end_layout

\begin_layout Plain Layout

# (make.grid.matrix is an own function similar to expand.grid)
\end_layout

\begin_layout Plain Layout

k.grid = make.grid.matrix(x=k.seq,n=2)
\end_layout

\begin_layout Plain Layout

colnames(k.grid)=c("k1","k2")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Solve the model for all combinations of k1 and k2
\end_layout

\begin_layout Plain Layout

m.list = pg.games(X=0:10,k1=k.grid[,1],k2=k.grid[,2])
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

# Show level plot of payoffs for delta=0.5
\end_layout

\begin_layout Plain Layout

delta = 0.5
\end_layout

\begin_layout Plain Layout

levelplot.payoff.compstat(m.list, par = k.grid ,
\end_layout

\begin_layout Plain Layout

  xvar = "k1", yvar = "k2", payoff.var="Ue",
\end_layout

\begin_layout Plain Layout

  delta = delta, col.scheme = "grey")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pg_compstatk1k2 V1.eps
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Payoff comparative statics in costs of the two players
\begin_inset CommandInset label
LatexCommand label
name "fig:compstat_pg_k1k2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
For low levels of production costs 
\begin_inset Formula $k_{1}$
\end_inset

 and 
\begin_inset Formula $k_{2}$
\end_inset

, the iso-profit curves are linear, i.e.
 total payoffs only depend on the sum of production costs 
\begin_inset Formula $k_{1}+k_{2}$
\end_inset

.
 This result makes perfect sense, since if both production costs are low,
 players do not have strong incentives to deviate and optimally choose full
 contribution 
\begin_inset Formula $x_{1}=x_{2}=10$
\end_inset

.
 
\end_layout

\begin_layout Standard
For larger production costs, iso-profit curves are no longer linear and
 the cost of the low cost player is more decisive for total profits.
 This makes intuitive sense in so far that it is optimal to shift public
 good provision to the low cost player who may receive a monetary reimbursement
 from the high cost player.
 If production costs become too large that they fall into the black area
 on the top right, no contributions can be sustained.
\end_layout

\begin_layout Standard
To generate a flip-book of these plots for different levels of 
\begin_inset Formula $\delta$
\end_inset

, turn on the graphic recording in R, paste the code below and finally click
 on the plot window and go for- and backward with the arrow keys:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

for (delta in seq(0,1,by=0.1)) {
\end_layout

\begin_layout Plain Layout

	levelplot.payoff.compstat(m.list, par = k.grid,
\end_layout

\begin_layout Plain Layout

      xvar = "k1", yvar = "k2", payoff.var="Ue",
\end_layout

\begin_layout Plain Layout

      delta = delta, col.scheme = "grey") 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Analyzing n-player games
\end_layout

\begin_layout Standard
While so far we only investigated games with 
\begin_inset Formula $n=2$
\end_inset

 players, the toolbox can also analyze repeated games with more players.
 While for 2 players it is convenient to specify the stage game payoffs
 by simply passing the payoff matrix of both players to the function 
\family typewriter
init.model
\family default
, there is a different way to specify payoffs for general n-player games.
 Let us first look at an example:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# Creates a n-player public goods game
\end_layout

\begin_layout Plain Layout

# n is the number of players.
 
\end_layout

\begin_layout Plain Layout

# X is the set of different contribution levels
\end_layout

\begin_layout Plain Layout

# k is a n x 1 vector with production costs for every player
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

pg.game = function(n,X,k=rep(((1+1/n)/2),n)) {
\end_layout

\begin_layout Plain Layout

  # A function that returns a payoff matrix
\end_layout

\begin_layout Plain Layout

  # given a action matrix x.mat, of which
\end_layout

\begin_layout Plain Layout

  # every row corresponds to one action profile
\end_layout

\begin_layout Plain Layout

  g.fun = function(x.mat) {
\end_layout

\begin_layout Plain Layout

    g = matrix(0,NROW(x.mat),n)
\end_layout

\begin_layout Plain Layout

    xsum = rowSums(x.mat)
\end_layout

\begin_layout Plain Layout

    for (i in 1:n) {
\end_layout

\begin_layout Plain Layout

      g[,i] = xsum / n - k[i]*x.mat[,i]
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    g
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  name=paste(n,"Player Public Goods Game")
\end_layout

\begin_layout Plain Layout

  m = init.game(n=n,g.fun=g.fun,action.val = X,
\end_layout

\begin_layout Plain Layout

	             name=name, lab.ai=round(X,2))
\end_layout

\begin_layout Plain Layout

  m=solve.game(m)
\end_layout

\begin_layout Plain Layout

  plot(m)
\end_layout

\begin_layout Plain Layout

  m
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

# Solve a 3 player public goods game with
\end_layout

\begin_layout Plain Layout

# asymmetric production costs
\end_layout

\begin_layout Plain Layout

m = pg.game(n=3,X=0:10,k=c(0.4,0.6,0.8))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Instead of passing payoff matrices to the function 
\family typewriter
init.game
\family default
, we pass a user defined function 
\family typewriter
g.fun
\family default
 and a vector (or list of vectors for every player) 
\family typewriter
action.val
\family default
.
 The parameter 
\family typewriter
action.val
\family default
 simply associates to every action of a player some number.
 Here it will simply be the contribution level.
 The function 
\family typewriter
g.fun
\family default
 takes a vector of action profiles (i.e.
 a matrix of action values, where every row corresponds to an action profile)
 and returns a corresponding matrix of stage game payoffs.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsubsection*

\emph on
Advanced Programming Hint:
\end_layout

\begin_layout Plain Layout
When I define the function 
\family typewriter
g.fun
\family default
 within the function 
\family typewriter
pg.game
\family default
, I use in the function body of 
\family typewriter
g.fun
\family default
 the local variables 
\family typewriter
n
\family default
 and 
\family typewriter
k
\family default
 from 
\family typewriter
pg.game
\family default
.
 R saves information in which environment the function 
\family typewriter
g.fun
\family default
 was created and when 
\family typewriter
g.fun
\family default
 is called somewhere later, it will look up its variables from that original
 environment.
 The local environment information will be retained even after the function
 
\family typewriter
pg.game
\family default
 is exited.
 To see how it works, consider the following code example:
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

make.f = function(i,j) {
\end_layout

\begin_layout Plain Layout

  f = function() {
\end_layout

\begin_layout Plain Layout

    i
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  i=j
\end_layout

\begin_layout Plain Layout

  return(f)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

f = make.f(i=1,j=2)
\end_layout

\begin_layout Plain Layout

g = function() {
\end_layout

\begin_layout Plain Layout

  i=3
\end_layout

\begin_layout Plain Layout

  return(f())
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

i=4
\end_layout

\begin_layout Plain Layout

# What will be the output of the following call?
\end_layout

\begin_layout Plain Layout

g()
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Any guess what the call 
\family typewriter
g()
\family default
 will return? It will be 2.
 The function 
\family typewriter
f
\family default
 looks up in in the local environment associated with the call to 
\family typewriter
make.f
\family default
 where 
\family typewriter
f
\family default
 was created.
 In that local environment 
\family typewriter
i
\family default
 took the value of 
\family typewriter
j
\family default
, i.e.
 2, before we exited 
\family typewriter
make.f
\family default
.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the number of action profiles grows exponentially with the number
 of players.
 While the software should handle perfect monitoring games up to a million
 action profiles well and quickly on normal PCs, a too large number of action
 profiles can lead to problems, like running out of memory or excessive
 computation time.
 For approximating continuous stage games or games with a large number of
 players, you should use the approach presented in Sections 5 and 6.
\end_layout

\begin_layout Standard
Before concluding this subsection, let us have a look at the joint equilibrium
 payoffs as function of total liquidity:
\end_layout

\begin_layout LyX-Code
 plot(m,xvar="L",identify=TRUE) 
\end_layout

\begin_layout Standard
We can see in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pg_game_3player"

\end_inset

, that 
\begin_inset Formula $\bar{U}^{e}(L)$
\end_inset

 is a concave piece-wise linear function in L.
 You probably have some conjecture why we have these kinks in 
\begin_inset Formula $\bar{U}^{e}(L)$
\end_inset

.
 You can strengthen your intuition by using left-clicks to interactively
 explore the plot.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pg_3player.eps
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Public goods game (3 players with asymmetric costs)
\begin_inset CommandInset label
LatexCommand label
name "fig:pg_game_3player"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Exercises
\end_layout

\begin_layout Standard
The two exercises below ask you to explore some variations of repeated public
 goods games by modifying the examples described above.
\end_layout

\begin_layout Exercise

\series bold
More Comparative Statics for Public Goods Games
\series default
 In the experimental literature, linear public goods game are often parametrized
 in a different way than presented above.
 Cost of contributing one unit is typically normalized to one and key parameters
 are the marginal per capita return and the marginal total return of one
 contributed unit.
 Isaak & Walker (1988) and others found the following stylized facts from
 economic experiments on finitely repeated public goods games: 
\end_layout

\begin_deeper
\begin_layout Itemize
Ceteris-paribus, the level of contributions increases in the marginal per
 capita return.
 In other words, keeping the marginal total return constant, average contributio
n levels typically fall in the number of subjects.
\end_layout

\begin_layout Itemize
There is also weaker evidence that average contributions increase if the
 marginal per capita return is kept constant, but the number of subjects
 and with it the total return of contributions increase.
\end_layout

\end_deeper
\begin_layout Exercise
Reparametrize the public goods game using marginal per capita return, number
 of players and marginal total return as possible parameters (of course
 only 2 of them will be actually passed to the function).
 Analyze the comparative statics of contribution levels (or critical discount
 factors) with respect to the different parameters.
 Are they roughly in line with the experimental stylized facts from finitely
 repeated public goods games? Compare your comparative statics with those
 of your most favorite model of social preferences.
 If you should not yet have chosen a most favorite social preference model,
 have a look at Kranz (2010)! :) 
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise

\series bold
Public Goods Games with a Costly Punishment Technology
\series default
 Write a new function that allows to solve repeated public goods games,
 in which players can assign costly reduction points to the other player
 to reduce his payoffs.
 Stage game payoffs shall be given by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
g_{i}(x,r)=\frac{x_{1}+x_{2}}{2}-k_{i}x_{i}-r_{j}-\gamma_{i}r_{i}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $r_{i}$
\end_inset

 is the number reduction points that player 
\begin_inset Formula $i$
\end_inset

 assigns to player 
\begin_inset Formula $j$
\end_inset

 and 
\begin_inset Formula $\gamma_{i}>0$
\end_inset

 shall be a parameter that measures the cost of assigning one reduction
 point.
 Reduction points 
\begin_inset Formula $r_{i}$
\end_inset

 and contribution levels 
\begin_inset Formula $x_{i}$
\end_inset

 must be chosen from some finite set.
 (Hint: The action space becomes simpler, if you assume that in a given
 period players can either contribute to the public good or assign reduction
 points, but cannot do both at the same time.).
\end_layout

\begin_layout Standard
In economic experiments on finitely repeated (or one shot) public goods
 games, it often turns out that augmenting the public goods game by a punishment
 technology substantially increase average contribution levels
\end_layout

\begin_layout Standard
Answer the following questions: Can the inclusion of such a punishment technolog
y also increase the maximal sustainable contribution levels in infinitely
 repeated games? What if we would not calculate optimal equilibria, but
 only restricted attention to grim-trigger strategies?
\end_layout

\begin_layout Standard
Also perform some comparative statics with respect to the different parameters
 of the game.
 
\end_layout

\begin_layout Standard
As extension, analyze public goods games with three player and compare punishmen
t technologies that can target reduction points on specific players with
 anonymous punishment technologies that always distribute reduction points
 equally.
\end_layout

\begin_layout Section
Approximating Continuous Cournot Models 
\end_layout

\begin_layout Standard
In this Section I want to illustrate, how for the case of perfect monitoring
 the toolbox can handle fine approximations of stage games with continuous
 action spaces.
 In Subsection 5.3, I will also illustrate, how one can handle games where
 some players have a multidimensional action spaces (e.g.
 selling multiple products).
 
\end_layout

\begin_layout Subsection
Approximating a Cournot oligopoly with the known methods
\end_layout

\begin_layout Standard
The stage game shall be a symmetric linear Cournot model with 
\begin_inset Formula $n$
\end_inset

 firms, who face an inverse linear demand function of the form
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
P(Q)=A-BQ.
\]

\end_inset


\end_layout

\begin_layout Standard
All firms shall have identical constant marginal costs 
\begin_inset Formula $MC$
\end_inset

.
\end_layout

\begin_layout Standard
One way to approximate this game is simply to specify a grid of action profiles
 and use the method illustrated in Section 4.3.
 The following code initializes and solves a two player Cournot game of
 this class with 
\begin_inset Formula $A=100$
\end_inset

, 
\begin_inset Formula $B=1$
\end_inset

 and 
\begin_inset Formula $MC=10$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

init.cournot = function(n=2,q.seq, A, B, MC) {
\end_layout

\begin_layout Plain Layout

  P.fun = function(Q) {A-B*Q}
\end_layout

\begin_layout Plain Layout

  cost.fun = function(q) {MC*q}  
\end_layout

\begin_layout Plain Layout

  g.fun = function(qm) {
\end_layout

\begin_layout Plain Layout

    Qm = rowSums(qm)
\end_layout

\begin_layout Plain Layout

    Pm = P.fun(Qm)
\end_layout

\begin_layout Plain Layout

    Pm[Pm<0]=0
\end_layout

\begin_layout Plain Layout

    g = matrix(NA,NROW(qm),n)
\end_layout

\begin_layout Plain Layout

    for (i in 1:n) {
\end_layout

\begin_layout Plain Layout

      g[,i] = Pm*qm[,i]-cost.fun(qm[,i])
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    g
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  name=paste(n,"Cournot Game (g.fun)")
\end_layout

\begin_layout Plain Layout

  m = init.game(n=2,g.fun=g.fun,action.val = q.seq,
\end_layout

\begin_layout Plain Layout

                name=name, lab.ai=round(q.seq,2))
\end_layout

\begin_layout Plain Layout

  return(m)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

# Parameters of the model
\end_layout

\begin_layout Plain Layout

n=2; A=100; B=1; MC=10;
\end_layout

\begin_layout Plain Layout

q.seq = seq(0,100,by=1); # Grid of possible quantities
\end_layout

\begin_layout Plain Layout

m = init.cournot(n=n,q.seq=q.seq,A=A,B=B,MC=MC)
\end_layout

\begin_layout Plain Layout

m = solve.game(m)
\end_layout

\begin_layout Plain Layout

plot(m,legend.pos = "right")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The models is solved very quickly and you see the resulting payoffs for
 shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Payoffs-Cournot-Duopoly"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename cournot_2_payoffs.eps
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Payoffs for discretized Cournot Duopoly
\begin_inset CommandInset label
LatexCommand label
name "fig:Payoffs-Cournot-Duopoly"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We find that firms can perfectly collude already for very low discount factors.
 (Section 8, shows how monitoring imperfections make collusion much harder...).
 
\end_layout

\begin_layout Standard
Now let us analyze what happens if there are more firms in the market.
 Set the parameter 
\begin_inset Formula $n=4$
\end_inset

, init and solve the model.
 Does your program run without error and in reasonable time? Then congratulation
s to your computer's memory...
 on my computer the program refuses to run and throws an out of memory error.
\end_layout

\begin_layout Standard
Basically, with 4 firms and 100 actions per firm, the discretized version
 of the stage game has 
\begin_inset Formula $100^{4}$
\end_inset

 = 100 million action profiles.
 My computer cannot solve it, because the underlying algorithm used for
 solving the game is not very memory efficient.
 It generates a matrix of all possible action profiles and manipulates it.
\end_layout

\begin_layout Standard
Besides the issue of practical computation there is also a small theoretical
 issue.
 The algorithm used above calculates cheating payoffs by considering only
 the action profiles from the specified grid, cheating payoffs in the continuous
 version of the stage game might be higher, however.
 As result, it is not clear whether the resulting payoff set of the discretized
 game is a lower or upper approximation of the payoff set of the continuous
 game.
\end_layout

\begin_layout Subsection
Alternative ways to solve models with continuous action spaces
\end_layout

\begin_layout Standard
The toolbox contains alternative procedures for games with perfect monitoring,
 which facilitate the analysis fine discretizations of multidimensional
 continuous stage games and guarantee that the computed payoff sets are
 always a lower approximation of the payoff sets of the continuous game.
 These procedures can be recognized by the prefix 
\family typewriter
pmx
\family default
.
\end_layout

\begin_layout Standard
The procedures require that in addition to the stage game payoffs 
\begin_inset Formula $g(a)$
\end_inset

, you also have to manually provide functions that calculate cheating payoffs
 
\begin_inset Formula $c(a)$
\end_inset

 for any possibly relevant
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
If on theoretical grounds, we can rule out some action profiles as candidates
 for optimal action profiles, we also do not have to provide cheating payoffs
 (see Section 6, for an example)
\end_layout

\end_inset

 action profile of the continuous stage game 
\begin_inset Formula $a\in A$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In principle, one could obtain an approximation of the general function
 
\begin_inset Formula $c(a)$
\end_inset

 by telling R to perform numeric optimization using the stage game payoff
 function 
\begin_inset Formula $g(a)$
\end_inset

.
 However, I fear that this would be quite slow, i.e.
 closed form solutions to 
\begin_inset Formula $c(a)$
\end_inset

 are preferable.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
In the Cournot game above, we know that firm 
\begin_inset Formula $i$
\end_inset

's best-reply function is given by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
q_{i}^{*}(Q_{-i})=max\left\{ \frac{A-MC}{2B}-\frac{1}{2}Q_{-i},0\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
The corresponding cheating payoffs are given by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
c(q)=\begin{cases}
\frac{\left(A-MC-BQ_{-i}\right)^{2}}{4B} & \mbox{if \ensuremath{A-MC-BQ_{-i}>0}}\\
0 & \mbox{otherwise}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Generally, knowing the payoff function 
\begin_inset Formula $g(a)$
\end_inset

 and cheating payoff function 
\begin_inset Formula $c(a)$
\end_inset

, we can calculate the liquidity requirement 
\begin_inset Formula $L(a)$
\end_inset

, joint payoffs 
\begin_inset Formula $G(a)$
\end_inset

 and player 
\begin_inset Formula $i$
\end_inset

's cheating payoffs for any sampled action profile 
\begin_inset Formula $a$
\end_inset

.
 To compute inner approximations of the sets of SPE payoffs, we can draw
 a finite random sample of action profiles in order to calculate lower bounds
 of the functions 
\begin_inset Formula $\bar{U}^{e}(L)$
\end_inset

 and 
\begin_inset Formula $\bar{v}^{i}(L)$
\end_inset

 for the continuous game.
 As the sample size grows large, these lower bounds converge in probability
 to the true functions and the corresponding payoff sets converge from the
 inside to the true payoff sets of the continuous stage game.
\end_layout

\begin_layout Standard
The practical issue is to sample action profiles in a way that achieves
 relatively quick convergence for most stage games.
 I implemented so far two approaches that can each be parametrized in different
 ways.
 The first approach is a very simple adaptive grid refinement method that
 does not rely heavily on random sampling, the second approach uses more
 random sampling.
\end_layout

\begin_layout Standard
Before discussing some more details of the algorithms, let me show how to
 use them.
 Using the alternative methods requires to initialize the stage game with
 the function 
\family typewriter
pmx.init.game
\family default
, instead of using
\family typewriter
 init.game.

\family default
 The following code initializes and solves the Cournot game for 4 players
 using the new methods:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

pmx.init.cournot = function(n=2, q.range, A, B, MC) {
\end_layout

\begin_layout Plain Layout

  # First part
\end_layout

\begin_layout Plain Layout

  store.objects("pmx.init.cournot")
\end_layout

\begin_layout Plain Layout

  #restore.objects("pmx.init.cournot")
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

  # Stage game payoffs
\end_layout

\begin_layout Plain Layout

  gx.fun = function(q) {
\end_layout

\begin_layout Plain Layout

    Q = rowSums(q)
\end_layout

\begin_layout Plain Layout

    P = A-B*Q
\end_layout

\begin_layout Plain Layout

    P[P<0]=0
\end_layout

\begin_layout Plain Layout

    g = matrix(NA,NROW(q),n)
\end_layout

\begin_layout Plain Layout

    for (i in 1:n) {
\end_layout

\begin_layout Plain Layout

      g[,i] = (P-MC)*q[,i]
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    g
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  # Stage game cheating payoffs
\end_layout

\begin_layout Plain Layout

  cx.fun = function(q) {
\end_layout

\begin_layout Plain Layout

    Q   = rowSums(q)
\end_layout

\begin_layout Plain Layout

    c.mat = matrix(NA,NROW(q),n)
\end_layout

\begin_layout Plain Layout

    for (i in 1:n) {
\end_layout

\begin_layout Plain Layout

      Q_i = Q-q[,i]
\end_layout

\begin_layout Plain Layout

      c.mat[,i] = (A-MC-B*(Q-q[,i]))^2 / (4*B)
\end_layout

\begin_layout Plain Layout

      c.mat[A-MC-B*(Q-q[,i])<0,i] = 0
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    c.mat
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  # Second part
\end_layout

\begin_layout Plain Layout

  name=paste("Cournot Game (",n," firms)",sep="")
\end_layout

\begin_layout Plain Layout

  m = pmx.init.game(n=n,nx=n,x.range=q.range,symmetric=TRUE,
\end_layout

\begin_layout Plain Layout

        gx.fun=gx.fun,cx.fun=cx.fun, 
\end_layout

\begin_layout Plain Layout

        name=name, names.x=paste("q",1:n,sep=""))
\end_layout

\begin_layout Plain Layout

  return(m)
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

# Parameters of the model
\end_layout

\begin_layout Plain Layout

n=4; A=100; B=1; MC=10;
\end_layout

\begin_layout Plain Layout

q.max = A / (n-1)   # maximal output a firm can choose
\end_layout

\begin_layout Plain Layout

m = pmx.init.cournot(n=n,q.range=c(0,q.max),A=A,B=B,MC=MC)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Take a look at the line m = pmx.init.game(...).
 The parameter n denotes, as usual, the number of players.
 We have a new parameter nx, which denotes the number of 
\begin_inset Quotes eld
\end_inset

activities
\begin_inset Quotes erd
\end_inset

.
 An activity is some real number that influences stage game payoffs and
 a players' action may consist of one or several activities.
 In the Cournot example every player decides only on a single activity:
 the output in the market.
 This means actions and activities are identical.
 Below, we will explore a model of multi-market collusion, where every firm's
 action can consist of several activities.
 The parameter x.range specifies the intervals of the real line out of which
 activities have to be selected.
 If can either by a 
\begin_inset Formula $nx\times2$
\end_inset

 matrix, where each row specifies separate ranges for every activity, or
 if every activity shall have the same range, the x.range can be given by
 a simple tuple (x.min,x.max).
 Here the minimal output of each firm shall be 
\begin_inset Formula $0$
\end_inset

 and the maximal output 
\begin_inset Formula $A/(n-1)$
\end_inset

.
 This means 
\begin_inset Formula $n-1$
\end_inset

 firms are able to produce a total output that yields to a market price
 of zero.
 You can choose a larger bound if you like.
\end_layout

\begin_layout Standard
The parameter gx.fun specifies a function that returns a 
\begin_inset Formula $T\times n$
\end_inset

 dimensional matrix of payoffs given an 
\begin_inset Formula $T\times nx$
\end_inset

 matrix of activities, in which each row corresponds to one activity profile.
 Similarly, the function cx.fun must return a matrix of cheating payoffs
 for every player given a matrix of activities.
 Finally, the parameter names.x is a vector that specifies a label for each
 activity.
\end_layout

\begin_layout Standard
The following code solves the model using the adaptive grid refinement method:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# Solve with adaptive grid refinement
\end_layout

\begin_layout Plain Layout

cnt = list(method="grid",
\end_layout

\begin_layout Plain Layout

           num.step.start = 8, num.step.end = 128 ,
\end_layout

\begin_layout Plain Layout

           step.size.factor = 4, grid.size = 100000)
\end_layout

\begin_layout Plain Layout

m.grid = solve.game(m,cnt=cnt)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Solving the model takes, some time but we considered a relatively fine approxima
tion.
 The solution method and corresponding control parameters are specified
 in a list 
\family typewriter
cnt
\family default
.
 The adaptive grid refinement method and the meaning of the parameters is
 explained in the box below (a slightly different parametrization is given
 in Section 6).
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
The adaptive grid refinement method
\end_layout

\begin_layout Plain Layout
The algorithm performs the following procedure for every state 
\begin_inset Formula $k=e,1,...n$
\end_inset

, to approximate the functions 
\begin_inset Formula $\bar{U^{e}}(L)$
\end_inset

 and 
\begin_inset Formula $\bar{v}^{i}(L)$
\end_inset


\begin_inset Formula $.$
\end_inset

 I will explain it for the equilibrium state.
 Basically, the algorithm starts with a coarse grid of action profiles and
 notes which action profiles are optimal on that coarse grid.
 The parameter 
\family typewriter
num.step.start = 8
\family default
, specifies that the initial grid shall consists of 8 levels per activity,
 i.e.
 the initial grid contains 
\begin_inset Formula $8^{4}=4096$
\end_inset

 different activity profiles.
 For all of them, we calculate 
\begin_inset Formula $G(a)$
\end_inset

 and 
\begin_inset Formula $L(a)$
\end_inset

 and keep those profiles 
\begin_inset Formula $\hat{A}$
\end_inset

 that are optimal in the sense that for no 
\begin_inset Formula $\hat{a}\in\hat{A}$
\end_inset

 there is some other profile 
\begin_inset Formula $a$
\end_inset

 on the coarse grid with 
\begin_inset Formula $L(a)\leq L(\hat{a})$
\end_inset

 and 
\begin_inset Formula $G(a)\geq G(\hat{a})$
\end_inset

 with one of the inequalities holding strictly.
 These action profiles can be used to generate a first approximation to
 the function 
\begin_inset Formula $\bar{U}^{e}(L)$
\end_inset

.
\end_layout

\begin_layout Plain Layout
In the next step, we refine the grid by dividing the step size by the specified
 parameter step.size.factor.
 Instead of examining every activity profile in the global grid over the
 whole activity range, we examine local grids around those points that were
 optimal in the coarse grid.
 So basically, I take every point that was optimal and examine a 
\family typewriter
nx
\family default
 dimensional local grid with that point in the center.
 The maximum size of the local grid is given by the parameter 
\family typewriter
grid.size
\family default
.
 For the given maximal grid.size of 100000 and a 4 dimensional activity space,
 the local grid extends 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
floor\left[\frac{1}{2}\left(\frac{log(100000)}{log(4)}-1\right)\right]=3
\]

\end_inset


\end_layout

\begin_layout Plain Layout
steps in every direction.
 Points in the local grid that are optimal, will be added to 
\begin_inset Formula $\hat{A}$
\end_inset

 and those that cease to be optimal will be removed.
 If we find an optimal point at the boundary of a local grid, we will also
 explore a local grid around that point.
\end_layout

\begin_layout Plain Layout
The algorithm proceeds in this fashion until the number of grid points per
 activity rises above the parameter num.step.end.
\end_layout

\begin_layout Plain Layout
One can also set a flag 
\family typewriter
use.random.start.points = TRUE
\family default
.
 One then uses a variant of the algorithm in which the initial grid is not
 fully explored, but a random sample of points (by default 50000) is drawn
 and the algorithm proceeds with the optimal points from this sample.
 The advantage is that one can start with finer initial grids.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To give the user a feeling of the convergence process, I plot the actual
 approximations to the functions 
\begin_inset Formula $\bar{U^{e}}(L)$
\end_inset

 and 
\begin_inset Formula $\bar{v}^{i}(L)$
\end_inset

 during the solution process.
\end_layout

\begin_layout Standard
Let us solve the model again using the random sampling algorithm:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# Solve with random sampling
\end_layout

\begin_layout Plain Layout

cnt = list(method="random", step.size=0.1,
\end_layout

\begin_layout Plain Layout

           size.draw = 1000,num.draws = 200,
\end_layout

\begin_layout Plain Layout

           local.abs.width=4, prob.draw.global = 0.3)
\end_layout

\begin_layout Plain Layout

m.ran = solve.game(m,cnt=cnt)
\end_layout

\begin_layout Plain Layout

plot(m.ran)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
The basic idea of the algorithm is explained in the box below.
 
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
About the random sampling method
\end_layout

\begin_layout Plain Layout
Basically, we could simple sample activity profiles by drawing activities
 independent from each other and calculate the resulting approximations
 for 
\begin_inset Formula $\bar{U^{e}}(L)$
\end_inset

 and 
\begin_inset Formula $\bar{v}^{i}(L)$
\end_inset

 from the drawn activity profiles.
 If we draw sufficient many profiles, we will converge in probability towards
 the true functions.
 There are several ways to improve small sample performance, however.
 
\end_layout

\begin_layout Plain Layout
My algorithm does the following:
\end_layout

\begin_layout Plain Layout
The algorithm still uses a combination of local and global grid search.
 With probability prob.draw.global a random sample of activity profiles is
 drawn from the global grid and with probability 1-prob.draw.global from a
 local grid around some optimal point (each edge of the local hypercube
 of size local.abs.width).
 Each random sample has size size.draw and a total of num.draws samples is
 drawn.
\end_layout

\begin_layout Plain Layout
The crucial factor of the algorithm is that the separate activities that
 form an action profile are not always independently drawn from each other.
 For a small number of activities this would not matter much, but below
 I will apply the algorithm also on a Cournot model with 100 firms.
 If the number of activities nx grows large, we have the problem that by
 a law of large numbers, the drawn activity profiles are very likely to
 look quite similar in some dimensions.
 For example, the average output across 100 firms would be unlikely to deviate
 much from the mean of the specified range.
 e.g.
 with respect to the average activity level within the profile.
 So it is helpful to draw from distributions that allow for positive or
 negative correlations between subsets of activities.
 I implemented a very simple procedure that does this job, which you can
 look up in the source code of the function pmx.draw.x.mat.
 
\end_layout

\begin_layout Plain Layout
Another issue is how to select the points, around which the local grid shall
 be extended.
 Simply choosing randomly from all optimal points, might have the effect
 that the grid gets refined only at some particular location, where in each
 refinement step a lot of new optimal points are selected.
 To draw more evenly, I give precedence to those optimal points that were
 drawn from the global grid.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The system is even a bit refined.
 I say an optimal point drawn from the global grid is generation 0.
 An optimal point drawn from a local grid around a point of generation 
\begin_inset Formula $t$
\end_inset

 is of generation 
\begin_inset Formula $t+1$
\end_inset

.
 When choosing a local grid, I give precedence to points of lower generation.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
A more even search is also facilitated by the fact that I still draw from
 a finite grid, with size given by the parameter step.size.
 I never draw a local grid twice from some optimal point when there are
 still some optimal points left, from which I have not yet drawn a local
 grid.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Again you get a graphical illustration of the convergence process.
 The following code compares the approximated 
\begin_inset Formula $\bar{U^{e}}(L)$
\end_inset

 from the two solution methods:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# Compare the two models graphically
\end_layout

\begin_layout Plain Layout

plot.compare.models(m.grid,m.ran, xvar="delta", yvar="Ue",
\end_layout

\begin_layout Plain Layout

                    m1.name="grid", m2.name="random", 
\end_layout

\begin_layout Plain Layout

                    identify = TRUE, legend.pos="right")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The resulting plot is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:m.adr_vs_m.ran"

\end_inset

 below
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename cournot_4_compare.eps
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Comparing solutions of the two methods
\begin_inset CommandInset label
LatexCommand label
name "fig:m.adr_vs_m.ran"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We find that the two methods yield almost the same solutions, which is quite
 encouraging.
 The grid refinement method becomes quickly infeasible as the dimensionality
 of the action space increases, while the random sampling mechanism still
 tends to do a good job.
 Using the function call
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none">>=
\end_layout

\begin_layout Plain Layout

m=refine.solution(m,cnt=cnt)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
you can apply a different solution method described in 
\family typewriter
cnt
\family default
 on a game in order to refine a previous solution.
 You can refine a solution as often as you like.
\end_layout

\begin_layout Standard
To test the toolbox for 
\begin_inset Formula $n=100$
\end_inset

 firms, call:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# A hundred 100 firms                    
\end_layout

\begin_layout Plain Layout

# Parameters of the model
\end_layout

\begin_layout Plain Layout

n=100; A=100; B=1; MC=10;
\end_layout

\begin_layout Plain Layout

q.max = A / (n-1)   # maximal output a firm can choose
\end_layout

\begin_layout Plain Layout

m = pmx.init.cournot(n=n,q.range=c(0,q.max),A=A,B=B,MC=MC)
\end_layout

\begin_layout Plain Layout

cnt.e = list(method="random", step.size=0.05, 
\end_layout

\begin_layout Plain Layout

          local.abs.width = 0.5, prob.draw.global = 0.3,
\end_layout

\begin_layout Plain Layout

          size.draw = 1000,num.draws = 100)
\end_layout

\begin_layout Plain Layout

cnt.i = cnt.e
\end_layout

\begin_layout Plain Layout

cnt.i$num.draws = 400
\end_layout

\begin_layout Plain Layout

m.ran.100 = solve.game(m,cnt=cnt.e, cnt.i=cnt.i)
\end_layout

\begin_layout Plain Layout

plot(m.ran.100)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I chose to pick more samples for the characterization of the punishment
 state (cnt.i), since the graphical representation suggested that convergence
 for the punishment state went slower.
 Below, we will check how well our approximation for the 100 firms Cournot
 game worked.
\end_layout

\begin_layout Subsection
Finding and imposing restrictions on the structure of optimal action profiles
\end_layout

\begin_layout Standard
If for a problem at hand, we have some theoretical results about the structure
 of optimal action profiles, computational complexity may be substantially
 reduced.
 In particular, knowledge that w.l.o.g.
 we can impose some symmetry constraints can be very helpful.
 By analyzing different examples with the toolbox you can derive strong
 conjectures about whether some theoretical restrictions hold.
\end_layout

\begin_layout Standard
Ideally, the toolbox would allow you to study repeated games with the scientific
 method of empirical falsification approach to game theory: as long as you
 don't find a counter-example against your hypothesis you can put a stronger
 belief that its true.
 I must say only 
\begin_inset Quotes eld
\end_inset

ideally
\begin_inset Quotes erd
\end_inset

, since approximation and discretization errors (or programming errors)
 may sometimes seem to falsify a hypothesis even if it holds in the continuous
 version of the game.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Approximation and discretization errors, will be more of an issue for large
 stage games with imperfect public monitoring (see, e.g.
 Section 8) since computation time and memory restrictions but much stronger
 limits on the maximal grid sizes.
 I have no clue, how to develop a local grid refinement method for general
 games with imperfect monitoring.
 The problem is that alternative action profiles appear in the action constraint
s of the linear programs that calculate liquidity requirements and implementable
 payoffs.
 For games with perfect monitoring that problem can be circumvented, since
 our theoretical paper has shown that liquidity requirements only depend
 on stage game payoffs and stage game best-reply payoffs.
\end_layout

\end_inset

 So one needs some experience and game theoretic intuition to correctly
 interpret the results.
 And in the end...
 as game theorists, we finally should go proving our conjectures!
\end_layout

\begin_layout Standard
Since the stage game is symmetric there are two natural conjectures:
\end_layout

\begin_layout Enumerate
For the equilibrium state, we can restrict attention w.l.o.g.
 to symmetric action profiles as candidates for optimal profiles.
\end_layout

\begin_layout Enumerate
For the punishment state of player 
\begin_inset Formula $i$
\end_inset

, we can restrict attention w.l.o.g.
 to action profiles where all punishing players 
\begin_inset Formula $j\neq i$
\end_inset

 choose the same output.
\end_layout

\begin_layout Standard
There are two ways to use the toolbox get insights into these hypothesis.
 First, we can look whether the optimal action profiles that we found by
 solving the unrestricted problem satisfy the postulated restrictions.
 If this holds, I would strengthen my belief that we can impose those restrictio
ns w.l.o.g.
 If it does not hold, it does not necessarily prove that the conjectures
 are wrong, since there may be multiple optimal action profiles and the
 algorithm may have selected some that do not satisfy the condition.
\end_layout

\begin_layout Standard
The second way is to solve a restricted model that imposes the postulated
 restriction and to check whether the resulting payoff sets are the same
 than for the unrestricted problem.
 If the implementable payoff sets are smaller in the restricted problem
 (to a degree that seems not likely to be explained by approximation errors),
 it suggests that the conjecture was wrong.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Alternatively, a programming error took place.
 Like a mathematical proof, you should always check, whether there is a
 mistake somewhere in the code.
 Like in a mathematical proof, you may not always find every mistake however.
 Helpful for the search for bugs is that the program may throw an error
 or delivers strange outputs.
 Actually, debugging in R is quite fun, and I typically learn most about
 a problem after I have debugged my code.
 I give some hints on debugging in Appendix A.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us start with the first method.
 The following code, plots (for the previously solved model
\family typewriter
\color black
 m.grid
\family default
\color inherit
) the outputs of players 2 and 3 against the output of player 1 in the equilibri
um state and player 1's punishment state:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# Equilibrium state
\end_layout

\begin_layout Plain Layout

plot(m.grid,xvar="e.q1",yvar=c("e.q2","e.q3"),col=c("blue","red"),
\end_layout

\begin_layout Plain Layout

     main="Opt.
 equilibrium profiles")
\end_layout

\begin_layout Plain Layout

abline(a=0,b=1)
\end_layout

\begin_layout Plain Layout

# Punishment state
\end_layout

\begin_layout Plain Layout

plot(m.grid,xvar="1.q1",yvar=c("1.q2","1.q3"),col=c("blue","red"),
\end_layout

\begin_layout Plain Layout

     main="Opt.
 punishment profiles", legend.pos="topright")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
      
\end_layout

\begin_layout Standard
The resulting plots are shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Cournot-4-Action-Plans"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename cournot_4_qe.eps
	scale 60

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename cournot_4_q1.eps
	scale 60

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Plotting firms' optimal outputs in equilibrium state and punishment state
 against each other
\begin_inset CommandInset label
LatexCommand label
name "fig:Cournot-4-Action-Plans"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The plot on the left hand side suggests that perhaps w.l.o.g., we could restrict
 attention to symmetric equilibrium action profiles.
 The command 
\family typewriter
abline(a=0,b=1)
\family default
 simply did draw the black diagonal line with slope 1 in the left hand side.
 You can check whether these strange spikes begin to vanish, when you evaluate
 a finer grid.
 Similarly, the right hand side plot indicates that in firm 
\begin_inset Formula $i$
\end_inset

's punishment state it is optimal that the punishing firms chose the same
 output, while the punished firm chooses a different output.
 
\end_layout

\begin_layout Standard
Let us now solve a restricted model that imposes these symmetry constraints.
 Below you find the essential parts of the code, that you have to combine
 yourself with the code from the previous function to make it run.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

pmx.init.cournot.sym = function(n=2, q.range, A, B, MC) {
\end_layout

\begin_layout Plain Layout

  # First part
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  #...
 insert code from first part of pmx.init.cournot
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  # Second part: Code that specifies symmetry constraints
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

  # In equilibrium state only player 1 chooses freely his
\end_layout

\begin_layout Plain Layout

  # action other firms are assumed to choose symmetric actions
\end_layout

\begin_layout Plain Layout

  x.free.e = 1 
\end_layout

\begin_layout Plain Layout

  link.fun.e = function(xf.mat,k=NULL) {
\end_layout

\begin_layout Plain Layout

    # xf.mat will only have one column, which 
\end_layout

\begin_layout Plain Layout

    # contains the actions of firm 1
\end_layout

\begin_layout Plain Layout

    # return a matrix with n cols that are all identical to xf.mat
\end_layout

\begin_layout Plain Layout

    return(matrix(as.vector(xf.mat),NROW(xf.mat),n))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

  # In the punishment states only the punished player and one other player
\end_layout

\begin_layout Plain Layout

  # (here either player 1 or 2) can freely decide on their actions
\end_layout

\begin_layout Plain Layout

  x.free.i = lapply(1:n, function(i) c(1,i))
\end_layout

\begin_layout Plain Layout

  x.free.i[[1]] = c(1,2)
\end_layout

\begin_layout Plain Layout

  link.fun.i = function(xf.mat,k) {
\end_layout

\begin_layout Plain Layout

    if (k == 1) {
\end_layout

\begin_layout Plain Layout

      mat = matrix(as.vector(xf.mat[,2]),NROW(xf.mat),n)
\end_layout

\begin_layout Plain Layout

      mat[,1] = xf.mat[,1] 
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      mat = matrix(as.vector(xf.mat[,1]),NROW(xf.mat),n)
\end_layout

\begin_layout Plain Layout

      mat[,k] = xf.mat[,k] 
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return(mat)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

  m = pmx.init.game(n=n,nx=n,gx.fun=gx.fun,cx.fun=cx.fun,
\end_layout

\begin_layout Plain Layout

              x.range=q.range, symmetric=TRUE,
\end_layout

\begin_layout Plain Layout

              x.free.e = x.free.e, link.fun.e=link.fun.e, 
\end_layout

\begin_layout Plain Layout

              x.free.i = x.free.i,link.fun.i = link.fun.i,
\end_layout

\begin_layout Plain Layout

              name=paste("Cournot Game (",n," firms)",sep=""),
\end_layout

\begin_layout Plain Layout

              names.x=paste("q",1:n,sep=""))
\end_layout

\begin_layout Plain Layout

  return(m)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

# Parameters of the model
\end_layout

\begin_layout Plain Layout

n=100; A=100; B=1; MC=10;
\end_layout

\begin_layout Plain Layout

m = pmx.init.cournot(n=n,q.range=c(0,A / (n-1)),A=A,B=B,MC=MC)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The basic philosophy is that you can specify for each state a set of free
 actions and a link function that specifies the remaining actions of an
 action profile as function of the free actions.
 Under restriction to symmetric action profiles on the equilibrium state,
 we only need one free action profile.
 The line 
\family typewriter
x.free.e=1
\family default
 says that player 1's action shall be free.
 The function 
\family typewriter
link.fun.e
\family default
 must be a function that takes (besides the state 
\begin_inset Formula $k$
\end_inset

) as argument a matrix 
\family typewriter
xf.mat
\family default
 that specifies the free actions.
 Since only one action is free, the matrix will only have one column and
 each row will correspond to a different action of player 1 (the function
 will be repeatedly called with different actions as the algorithm unfolds).
 The function must return a matrix that specifies for each row of xf.mat
 the complete action profile.
 Here, simply every player chooses the same action profile than player 1.
\end_layout

\begin_layout Standard
For the punishment state of player 
\begin_inset Formula $i$
\end_inset

 we specify to free actions: the action of player 
\begin_inset Formula $i$
\end_inset

 and some other player (the other player is 1 unless 
\begin_inset Formula $i=1$
\end_inset

).
 The link function 
\family typewriter
link.fun.i
\family default
 returns a matrix in which all punishing players choose the same outputs.
\end_layout

\begin_layout Standard
If you run the model, you can indeed verify that the resulting optimal payoffs
 are the same than for the unrestricted model.
 To compare the models, store the solved unrestricted and restricted models
 in variables 
\family typewriter
m.u
\family default
 and 
\family typewriter
m.r
\family default
.
 One way to compare the payoffs, is to tell R to record the plotting history,
 then to plot the two models after each other and compare the graphs by
 switching between the plots.
 (There is also a more convenient function 
\family typewriter
plot.compare.models
\family default
, but I have not yet implemented it for perfect monitoring games).
\end_layout

\begin_layout Standard
The restricted model can be easily solved for a much larger number of firms,
 since the number of free actions remains constant.
 Try solving it for 
\begin_inset Formula $n=100$
\end_inset

.
 The only slight annoyance you might encounter is that the option 
\family typewriter
use.random.start.points = TRUE
\family default
 leads to slight inaccuracies in the calculation of punishment profiles
 if the number of firms is large.
\end_layout

\begin_layout Exercise
Check different specifications of the parameters of 
\family typewriter
cnt
\family default
 when solving the symmetric model for a large number of firms and find a
 robust one that is considerably quick.
 Also try out the method 
\family typewriter
refine.solution
\family default
 for refining a solution with different solution methods.
 Perform some graphical comparative statics of the payoff sets with respect
 to the number of firms and other parameters that might interest you.
\end_layout

\begin_layout Standard
In Section 8, we will compare repeated Cournot oligopolies with perfect
 and imperfect monitoring.
 Some more exercises will be given there.
\end_layout

\begin_layout Section
Hotelling Competition and Multi Market Contact
\end_layout

\begin_layout Standard
This Section studies collusion in one or several markets that each are described
 by a Hotelling model.
 It exemplifies how one can model stage games where players can have multi-dimen
sional activity spaces.
 This Section also illustrates methods that help to check whether one correctly
 specified the cheating payoffs of the stage game.
\end_layout

\begin_layout Subsection
The Hotelling Stage Game
\end_layout

\begin_layout Standard
Consider 2 (or more) firms that compete with each other in 1, 2 or more
 different markets.
 In each market only two firms are active.
 Demand in each market is independent from prices in other markets and described
 by a linear Hotelling model.
\end_layout

\begin_layout Standard
More specifically, let us assume that in any given market, consumers are
 uniformly distributed over the unit interval 
\begin_inset Formula $[0,1]$
\end_inset

 and that the two active firms are located at the end points of the interval.
 For the following illustration, assume firm 1 is located at position 0
 and firm 2 at position 1.
 A consumer at position 
\begin_inset Formula $x\in[0,1]$
\end_inset

 gets a net benefit of 
\begin_inset Formula $w-p_{1}-x\tau$
\end_inset

 and 
\begin_inset Formula $w-p_{2}-(1-x)\tau$
\end_inset

 when buying a good from firm 1 or 2 at prices 
\begin_inset Formula $p_{1}$
\end_inset

 and 
\begin_inset Formula $p_{2}$
\end_inset

, respectively.
 The parameter 
\begin_inset Formula $w$
\end_inset

 measures the consumers' gross valuation for a good and 
\begin_inset Formula $\tau$
\end_inset

 is a measure of transportation costs.
 Each consumer has unit demand and buys at most from one firm and the mass
 of total consumers shall be given by a market size parameter 
\begin_inset Formula $S$
\end_inset

.
 
\end_layout

\begin_layout Standard
In an interior equilibrium, where both firms sell positive amounts and every
 consumer buys a product, firm 
\begin_inset Formula $i$
\end_inset

's demand is given by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
q_{i}^{c}(p_{i},p_{j})=\left(\frac{1}{2}+\frac{p_{j}\text{−}p_{i}}{2\tau}\right)S
\]

\end_inset


\end_layout

\begin_layout Standard
If consumers' valuation 
\begin_inset Formula $w$
\end_inset

 is too low, compared to the competitor's price, the monopolistic demand
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
q^{m}(p_{i})=\left(\frac{w-p_{i}}{\tau}\right)S
\]

\end_inset


\end_layout

\begin_layout Standard
becomes instead relevant for firm 
\begin_inset Formula $i$
\end_inset

.
 We also have to account for the boundary conditions that demand cannot
 be negative and cannot exceed 
\begin_inset Formula $S$
\end_inset

.
 We thus find that firm 
\begin_inset Formula $i$
\end_inset

's demand in the market is given by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
q_{i}(p_{i},p_{j})=\max\left\{ \min\left\{ q_{i}^{c}(p_{i},p_{j}),q_{i}^{m}(p_{i}),1\right\} ,0\right\} S.
\]

\end_inset


\end_layout

\begin_layout Standard
Firm 
\begin_inset Formula $i$
\end_inset

 has constant marginal costs of production 
\begin_inset Formula $c_{i}$
\end_inset

.
 We assume that prices are restricted to 
\begin_inset Formula $0\leq p_{i}\leq w$
\end_inset

.
\end_layout

\begin_layout Subsection
Finding errors in the best-reply functions
\end_layout

\begin_layout Standard
When Hotelling models are studied in one-shot games, it is usually assumed
 that the customers' gross value 
\begin_inset Formula $w$
\end_inset

 is relatively large compared to the Nash equilibrium prices and that both
 firms have identical cost.
 In that case, the relevant best-reply functions can be found under the
 assumptions that all consumers buy from one of the two firms and that there
 is an interior consumer 
\begin_inset Formula $\hat{x}\in(0,1)$
\end_inset

 who is indifferent between buying from either of the two firms.
 Then using the first order conditions, one finds that firm 
\begin_inset Formula $i$
\end_inset

's best-reply price is given by 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\hat{p}_{i}^{c}(p_{j})=\frac{1}{2}(p_{j}+c_{i}+\tau)
\]

\end_inset


\end_layout

\begin_layout Standard
If we want to study repeated games the actual value of 
\begin_inset Formula $w$
\end_inset

 becomes relevant for collusive prices and we may have to account for the
 fact that best-reply functions have a more complicated form.
 Nevertheless, to illustrate some debugging facilities, let us believe for
 the moment that the function above indeed specifies the best reply functions
 of the stage game.
 Then the code below initializes a Hotelling model with a single market
 and solves the repeated game.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

init.hotelling = function(ms,symmetric=FALSE) {
\end_layout

\begin_layout Plain Layout

  colnames(ms) = c("market","firm1","firm2",
\end_layout

\begin_layout Plain Layout

                   "MC1","MC2","tau","size","w")
\end_layout

\begin_layout Plain Layout

  n = max(ms[,c("firm1","firm2")])
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  store.objects()
\end_layout

\begin_layout Plain Layout

  #restore.objects("init.hotelling")
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

  # Stage game payoffs
\end_layout

\begin_layout Plain Layout

  gx.fun = function(p) {
\end_layout

\begin_layout Plain Layout

    store.objects("gx.fun")
\end_layout

\begin_layout Plain Layout

    #restore.objects("gx.fun")
\end_layout

\begin_layout Plain Layout

    g.mat = matrix(0,NROW(p),n)    
\end_layout

\begin_layout Plain Layout

    for (ma in 1:NROW(ms)) {
\end_layout

\begin_layout Plain Layout

      tau = ms[ma,"tau"];size = ms[ma,"size"]; w = ms[ma,"w"];
\end_layout

\begin_layout Plain Layout

      p1 = p[,ma*2-1];p2 = p[,ma*2];
\end_layout

\begin_layout Plain Layout

      q1 = pmax(0,pmin((w-p1)/tau,
\end_layout

\begin_layout Plain Layout

                pmin(1,(1/2+(p2-p1)/(2*tau)))))*size
\end_layout

\begin_layout Plain Layout

      q2 = pmax(0,pmin((w-p2)/tau,
\end_layout

\begin_layout Plain Layout

                  pmin(1,(1/2+(p1-p2)/(2*tau)))))*size
\end_layout

\begin_layout Plain Layout

      g.mat[,1] = g.mat[,1]+q1*(p1-ms[ma,"MC1"])
\end_layout

\begin_layout Plain Layout

      g.mat[,2] = g.mat[,2]+q2*(p2-ms[ma,"MC2"])
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    g.mat
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  # Stage game cheating payoffs.
 
\end_layout

\begin_layout Plain Layout

  #Assuming FOC specfies best reply prices
\end_layout

\begin_layout Plain Layout

  cx.fun = function(p) {
\end_layout

\begin_layout Plain Layout

    store.objects("cx.fun")
\end_layout

\begin_layout Plain Layout

    #restore.objects("cx.fun");
\end_layout

\begin_layout Plain Layout

    #restore.objects("init.hotelling")
\end_layout

\begin_layout Plain Layout

    c.mat = matrix(0,NROW(p),n)
\end_layout

\begin_layout Plain Layout

    ma = 1
\end_layout

\begin_layout Plain Layout

    while(ma <= NROW(ms)) {
\end_layout

\begin_layout Plain Layout

      tau = ms[ma,"tau"];size = ms[ma,"size"];w = ms[ma,"w"];
\end_layout

\begin_layout Plain Layout

      MC1 = ms[ma,"MC1"]; MC2 = ms[ma,"MC2"];
\end_layout

\begin_layout Plain Layout

      p1 = p[,ma*2-1];p2 = p[,ma*2];
\end_layout

\begin_layout Plain Layout

      p1.br = (1/2)*(p2+MC1+tau)
\end_layout

\begin_layout Plain Layout

      p2.br = (1/2)*(p1+MC2+tau)
\end_layout

\begin_layout Plain Layout

      q1 = pmax(0,pmin((w-p1.br)/tau,
\end_layout

\begin_layout Plain Layout

                pmin(1,(1/2+(p2-p1.br)/(2*tau)))))*size
\end_layout

\begin_layout Plain Layout

      q2 = pmax(0,pmin((w-p2.br)/tau,
\end_layout

\begin_layout Plain Layout

                pmin(1,(1/2+(p1-p2.br)/(2*tau)))))*size
\end_layout

\begin_layout Plain Layout

     
\end_layout

\begin_layout Plain Layout

      c.mat[,1] = c.mat[,1]+q1*(p1.br-MC1)
\end_layout

\begin_layout Plain Layout

      c.mat[,2] = c.mat[,2]+q2*(p2.br-MC2)
\end_layout

\begin_layout Plain Layout

      ma = ma+1
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    c.mat
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  name=paste("Hotelling (markets: ",NROW(ms),")", sep="")
\end_layout

\begin_layout Plain Layout

  nx = NROW(ms)*2
\end_layout

\begin_layout Plain Layout

  name.grid = make.grid.matrix(x=list(1:NROW(ms),1:2))
\end_layout

\begin_layout Plain Layout

  names.x = paste("m",name.grid[,1],".p",name.grid[,2],sep="")
\end_layout

\begin_layout Plain Layout

  x.range = cbind(0,rep(ms[,"w"],each=2))
\end_layout

\begin_layout Plain Layout

  m = pmx.init.game(n=n,nx=nx,x.range=x.range,symmetric=symmetric,
\end_layout

\begin_layout Plain Layout

        gx.fun=gx.fun,cx.fun=cx.fun, 
\end_layout

\begin_layout Plain Layout

        name=name, names.x=names.x)
\end_layout

\begin_layout Plain Layout

  return(m)
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

ms = matrix(c(
\end_layout

\begin_layout Plain Layout

 #market  firm1, firm2,   MC1,  MC2, tau, size,  w,
\end_layout

\begin_layout Plain Layout

       1,    1,     2,      10,  10, 100, 100,   200
\end_layout

\begin_layout Plain Layout

     ),ncol=8,byrow=TRUE)
\end_layout

\begin_layout Plain Layout

m = init.hotelling(ms=ms,symmetric=TRUE)
\end_layout

\begin_layout Plain Layout

cnt = list(method="grid", step.size.start=10,
\end_layout

\begin_layout Plain Layout

           step.size.end = 0.5, num.refinements = 1)
\end_layout

\begin_layout Plain Layout

m = solve.game(m,cnt=cnt)
\end_layout

\begin_layout Plain Layout

plot(m)
\end_layout

\begin_layout Plain Layout

m.unsure = m
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each row in the matrix 
\family typewriter
ms
\family default
 specifies the structure of one particular market.
 Here, we specified that there is only one market.
\end_layout

\begin_layout Standard
The function 
\family typewriter
solve.game
\family default
 runs on my computer without that the toolbox throws any error and I would
 say that the plot of equilibrium payoffs looks reasonable...
 Does that mean, we specified the correct best-reply function? Not necessarily.
 The following code allows to search for errors in the best reply-function:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

mat = check.cx.fun(m,num=30,method="grid",num.grid.steps=10000)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
check.cx.fun
\family default
 randomly samples 
\family typewriter
num
\family default
 action profiles and calculates for those action profiles the cheating payoffs
 for randomly selected players applying a numerical optimization procedure
 using the specified payoff function 
\family typewriter
m$gx.fun
\family default
 (by default it performs a grid search over the actions of the selected
 player).
 Then it compares these numerical results with the cheating payoffs specified
 by 
\family typewriter
m$cx.fun
\family default
.
 Information about the selected points and cheating payoffs is returned
 in a matrix.
 For example, type
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

round(mat[,"diff"],3)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
to see the vector of differences of the cheating payoffs specified by
\family typewriter
 cx.fun
\family default
 and the cheating payoffs from the grid search.
 The function 
\family typewriter
check.cx.fun
\family default
 also creates a plot that allows you compare the differences in calculated
 cheating payoffs graphically.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename cheating_payoffs_compare.eps
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Checking specified cheating payoff functions
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The black circles are the analytical cheating payoffs and the blue crosses
 the corresponding numerical results.
 If the blue crosses lie on the black circles (or slightly below, to a degree
 that depends on the coarseness of your grid search) everything is fine.
 If this is not the case everywhere (like on the right hand side of the
 shown plot), you misspecified the cheating payoffs.
\end_layout

\begin_layout Standard
Does this result mean that the calculated set of equilibrium payoffs is
 incorrect? Not necessarily, the plot indicates that at least for some subset
 of action profiles, we specified cheating payoffs correctly.
 By calling
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

mat = check.cx.fun(m,x.sample="opt.mat",
\end_layout

\begin_layout Plain Layout

                   method="grid",num.grid.steps=10000)
\end_layout

\begin_layout Plain Layout

round(mat[,"diff"],5)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
you can verify that the cheating payoffs were correctly calculated for the
 optimal action profiles.
 That means that there indeed exist equilibria that can implement the calculated
 optimal payoffs.
 However, we might have found a larger payoff set, if we would have specified
 a cheating payoff function that is correct for all action profiles.
\end_layout

\begin_layout Subsection
Specifying cheating payoff functions that use numerical optimization
\end_layout

\begin_layout Standard
You might wonder, why you have to specify a closed-form solutions for cheating
 payoffs if cheating payoffs can also be calculated by a grid search or
 some other numerical optimization procedure....
 Actually, it is possible to specify a function that calculates cheating
 payoffs by numerical optimization or grid search.
 The drawbacks are that solving the game can take considerably more time
 and there is no guarantee that the resulting payoff sets are inner approximatio
ns to the payoff sets of the continuous game if you only use a coarse grid
 search.
 The lines
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

m.num = init.hotelling(ms=ms,symmetric=TRUE)
\end_layout

\begin_layout Plain Layout

m.num$cx.fun = make.numerical.cx.fun(m.num,num.grid.steps=10000)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
tell the model to use a 
\family typewriter
cx.fun
\family default
 that calculates cheating payoffs using a grid search over 
\family typewriter
gx.fun
\family default
.
 So far, the function only works using a grid search and I only implemented
 it for games where each player has a single activity.
\end_layout

\begin_layout Standard
You will find that it takes considerably longer to solve the repeated game
 than for the case that closed-form solution for stage game cheating payoffs
 are provided.
 If you have two player games and don't know the cheating payoffs, you may
 rather prefer to use the methods explained in Sections 3, 4 and 5.1 to solve
 the game.
\end_layout

\begin_layout Subsection
Specifying correct best-reply functions
\end_layout

\begin_layout Standard
Let us now specify a correct closed-form function for stage game cheating
 payoffs.
 For simplicity, let us allow firms to set only prices that satisfy 
\begin_inset Formula $p_{1},p_{2}\leq w$
\end_inset

.
 Then given a price 
\begin_inset Formula $p_{j}$
\end_inset

 of the competitor, firm 
\begin_inset Formula $i$
\end_inset

 has several candidates for a best-reply:
\end_layout

\begin_layout Enumerate
Set the monopoly price 
\begin_inset Formula $p_{i}^{m}=\frac{w+c_{i}}{2}$
\end_inset

.
 This is optimal when given prices 
\begin_inset Formula $p_{j}$
\end_inset

 and firm 
\begin_inset Formula $i$
\end_inset

's monopoly price, not the whole market would be covered, i.e.
 if 
\begin_inset Formula $q^{m}(p_{i}^{m})+q^{m}(p_{j})\leq S$
\end_inset

.
 This condition is equivalent to
\begin_inset Formula 
\[
p_{j}\geq\frac{3}{2}w-\tau-\frac{1}{2}c_{i}
\]

\end_inset


\end_layout

\begin_layout Enumerate
Chose that price that gives firm 
\begin_inset Formula $i$
\end_inset

 exactly a market share of 
\begin_inset Formula $S-q^{m}(p_{j})$
\end_inset

.
 This price is given by
\begin_inset Formula 
\[
\hat{p}_{i}^{k}=2w-\tau-p_{j}
\]

\end_inset

Note that firm 
\begin_inset Formula $i$
\end_inset

's demand function has a kink at 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\hat{p}_{i}^{k}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Choose the interior best-reply price, which we already specified above
\begin_inset Formula 
\[
\hat{p}_{i}^{c}(p_{j})=\frac{1}{2}(p_{j}+c_{i}+\tau)
\]

\end_inset


\end_layout

\begin_layout Enumerate
Choose the highest price with which firm 
\begin_inset Formula $i$
\end_inset

 can steal the whole market from firm 
\begin_inset Formula $j$
\end_inset

:
\begin_inset Formula 
\[
\hat{p}_{i}^{s}=p_{j}-\tau
\]

\end_inset


\end_layout

\begin_layout Standard
The following modified cheating payoff function accounts for all four cases:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# Stage game cheating payoffs.
 Assuming FOC specifies best reply prices
\end_layout

\begin_layout Plain Layout

  cx.fun = function(p) {
\end_layout

\begin_layout Plain Layout

    store.objects("cx.fun")
\end_layout

\begin_layout Plain Layout

    #restore.objects("cx.fun");
\end_layout

\begin_layout Plain Layout

    #restore.objects("init.multimarket.hotelling")
\end_layout

\begin_layout Plain Layout

    c.mat = matrix(0,NROW(p),n)
\end_layout

\begin_layout Plain Layout

    ma = 1
\end_layout

\begin_layout Plain Layout

    while(ma <= NROW(ms)) {
\end_layout

\begin_layout Plain Layout

      tau = ms[ma,"tau"];size = ms[ma,"size"];w = ms[ma,"w"];
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      for (i in 1:2) {
\end_layout

\begin_layout Plain Layout

        j = 3-i
\end_layout

\begin_layout Plain Layout

        # Not very elegant but who cares...
\end_layout

\begin_layout Plain Layout

        if (i == 1) {
\end_layout

\begin_layout Plain Layout

          MC.i = ms[ma,"MC1"]; MC.j = ms[ma,"MC2"];
\end_layout

\begin_layout Plain Layout

          p.i = p[,ma*2-1];p.j = p[,ma*2];
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

          MC.j = ms[ma,"MC1"]; MC.i = ms[ma,"MC2"];
\end_layout

\begin_layout Plain Layout

          p.j = p[,ma*2-1];p.i = p[,ma*2];
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        # Try out the different best replies
\end_layout

\begin_layout Plain Layout

                
\end_layout

\begin_layout Plain Layout

        # kink
\end_layout

\begin_layout Plain Layout

        p.i.br = 2*w-tau-p.j
\end_layout

\begin_layout Plain Layout

        qi = pmax(0,pmin((w-p.i.br)/tau,
\end_layout

\begin_layout Plain Layout

                  pmin(1,(1/2+(p.j-p.i.br)/(2*tau)))))*size
\end_layout

\begin_layout Plain Layout

        pi.k = qi*(p.i.br-MC.i)
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        # interior
\end_layout

\begin_layout Plain Layout

        p.i.br = ((tau+MC.i+p.j)/2)
\end_layout

\begin_layout Plain Layout

        qi = pmax(0,pmin((w-p.i.br)/tau,
\end_layout

\begin_layout Plain Layout

                  pmin(1,(1/2+(p.j-p.i.br)/(2*tau)))))*size
\end_layout

\begin_layout Plain Layout

        pi.c = qi*(p.i.br-MC.i)
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        # steal the whole market from the other player
\end_layout

\begin_layout Plain Layout

        p.i.br = p.j-tau
\end_layout

\begin_layout Plain Layout

        qi = pmax(0,pmin((w-p.i.br)/tau,
\end_layout

\begin_layout Plain Layout

                    pmin(1,(1/2+(p.j-p.i.br)/(2*tau)))))*size
\end_layout

\begin_layout Plain Layout

        pi.s = qi*(p.i.br-MC.i)
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

        # Set monopoly price in those rows where pj is very high
\end_layout

\begin_layout Plain Layout

        pi.m = rep(0,NROW(p))
\end_layout

\begin_layout Plain Layout

        rows = (p.j >= (3/2)*w-tau-(1/2)*MC.i)
\end_layout

\begin_layout Plain Layout

        p.i.br = (w+MC.i)/2
\end_layout

\begin_layout Plain Layout

        qi = pmax(0,pmin((w-p.i.br)/tau,
\end_layout

\begin_layout Plain Layout

                  pmin(1,(1/2+(p.j-p.i.br)/(2*tau)))))*size
\end_layout

\begin_layout Plain Layout

        pi.m[rows] = (qi*(p.i.br-MC.i))[rows]
\end_layout

\begin_layout Plain Layout

               
\end_layout

\begin_layout Plain Layout

        # Take that best-reply that yields highest profits
\end_layout

\begin_layout Plain Layout

        c.mat[,i] = c.mat[,i]+pmax(pi.k,pmax(pi.c,pmax(pi.s,pi.m)))
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      ma = ma +1
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return(c.mat)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Exercise
Include the corrected function from above in the function 
\family typewriter
init.hotelling
\family default
.
 Check whether you can find any mistake in the cheating payoff function
 by using 
\family typewriter
check.cx.fun
\family default
.
 Using the function 
\family typewriter
plot.compare.model
\family default
, compare the payoff sets using the wrong specification of cheating payoffs,
 the cheating payoff function generated by 
\family typewriter
make.numerical.cx.fun
\family default
 and the correct specification of cheating payoffs (try the comparison for
 different values of 
\begin_inset Formula $w$
\end_inset

, for low values of 
\begin_inset Formula $w$
\end_inset

 you should not be able to solve the model with the wrongly specified cheating
 payoffs).
 Using the correctly specified cheating payoffs, perform comparative statics
 of the payoff set w.r.t.
 transportation cost (are maximal payoffs monotone in 
\begin_inset Formula $\tau$
\end_inset

?) and other variables of the model.
\end_layout

\begin_layout Subsection
Multi-market Collusion
\end_layout

\begin_layout Standard
The code below solves two models that differ by their transportation costs
 
\begin_inset Formula $\tau$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

cnt = list(method="grid", step.size.start=10,step.size.end = 0.5)
\end_layout

\begin_layout Plain Layout

ms = matrix(c(
\end_layout

\begin_layout Plain Layout

 #market  firm1, firm2,   MC1,  MC2, tau, size, w,
\end_layout

\begin_layout Plain Layout

       1,    1,     2,      10,  10, 100, 100,   400
\end_layout

\begin_layout Plain Layout

     ),ncol=8,byrow=TRUE)
\end_layout

\begin_layout Plain Layout

m = init.hotelling(ms=ms,symmetric=TRUE)
\end_layout

\begin_layout Plain Layout

m.high = solve.game(m,cnt=cnt)
\end_layout

\begin_layout Plain Layout

ms = matrix(c(
\end_layout

\begin_layout Plain Layout

 #market  firm1, firm2,   MC1,  MC2, tau, size, w,
\end_layout

\begin_layout Plain Layout

       1,    1,     2,      10,  10, 10,  100,   400
\end_layout

\begin_layout Plain Layout

     ),ncol=8,byrow=TRUE)
\end_layout

\begin_layout Plain Layout

m = init.hotelling(ms=ms,symmetric=TRUE)
\end_layout

\begin_layout Plain Layout

m.low = solve.game(m,cnt=cnt)
\end_layout

\begin_layout Plain Layout

plot.compare.models(m.high,m.low,xvar="delta",yvar="Ue",
\end_layout

\begin_layout Plain Layout

                    m1.name="high tau",m2.name="low tau",
\end_layout

\begin_layout Plain Layout

                    legend.pos = "bottomright")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
               
\end_layout

\begin_layout Standard
The resulting payoff comparison is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:high_tau_vs_low_tau"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename hotelling_high_vs_low_tau.eps
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Maximal Collusive Payoffs under high vs low transportation costs
\begin_inset CommandInset label
LatexCommand label
name "fig:high_tau_vs_low_tau"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
High transportation costs are preferable for firms under low discount factors
 as they facilitate high prices.
 However, as the discount factor grows large, firms' profits are higher
 under lower transportation costs since more surplus can then be extracted
 from consumers.
\end_layout

\begin_layout Standard
The code below solves a model where the same pair of firms is active in
 both market and can simultaneously collude in both markets.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# Parameters of the model
\end_layout

\begin_layout Plain Layout

ms = matrix(c(
\end_layout

\begin_layout Plain Layout

 #market  firm1, firm2,   MC1, MC2, tau, size, w,
\end_layout

\begin_layout Plain Layout

       1,    1,     2,     10,  10, 100, 100,   400,
\end_layout

\begin_layout Plain Layout

       1,    1,     2,     10,  10,  10, 100,   400
\end_layout

\begin_layout Plain Layout

     ),ncol=8,byrow=TRUE)
\end_layout

\begin_layout Plain Layout

m = init.hotelling(ms=ms,symmetric=TRUE)
\end_layout

\begin_layout Plain Layout

cnt = list(method="grid", step.size.start=5,step.size.end = 2,
\end_layout

\begin_layout Plain Layout

           num.refinements = 1,use.random.start.points = TRUE,
\end_layout

\begin_layout Plain Layout

           num.random.start.points=10000)           
\end_layout

\begin_layout Plain Layout

m = solve.game(m,cnt=cnt)
\end_layout

\begin_layout Plain Layout

m.mult = m
\end_layout

\begin_layout Plain Layout

plot(m.mult)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We solved the model using a grid search.
 You can always try to refine a solution, e.g.
 by using a different solution methods or different parameters.
 The following code tries out whether the a few random samples find better
 action profiles:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# As a check, try to refine the solution with random sampling
\end_layout

\begin_layout Plain Layout

cnt = list(method="random", step.size=0.1,
\end_layout

\begin_layout Plain Layout

           size.draw = 100,num.draws = 50,
\end_layout

\begin_layout Plain Layout

           local.abs.width=4, prob.draw.global = 1)
\end_layout

\begin_layout Plain Layout

m.mult = refine.solution(m.mult,cnt)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Most likely you won't see any relevant improvement in the graphical representati
on of the solution.
 The grid search seems to have worked fine.
 The following lines test our specification of the cheating payoffs:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

mat = check.cx.fun(m.mult,num=30,
\end_layout

\begin_layout Plain Layout

                   i.of.x = c(1,2,1,2), use.i = c(1,2),
\end_layout

\begin_layout Plain Layout

                   method="grid",num.grid.steps=300)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can repeat the function call above several times.
 The resulting plots should indicate that everything is fine.
\end_layout

\begin_layout Standard
To see whether multi-market contact facilitates collusion, it would be nice
 to compare the sum of payoffs from single market collusion with the maximal
 payoffs in the multi-market collusion model.
 The code below generates such a plot (shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:single vs multi market"

\end_inset

):
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# Generate matrices for same delta.sequence
\end_layout

\begin_layout Plain Layout

delta = seq(0,1,by=0.01)
\end_layout

\begin_layout Plain Layout

mat1 = get.mat.of.delta(m.high,delta = delta,add.crit.delta=FALSE)
\end_layout

\begin_layout Plain Layout

mat2 = get.mat.of.delta(m.low,delta = delta,add.crit.delta=FALSE)
\end_layout

\begin_layout Plain Layout

mat.b = get.mat.of.delta(m.mult,delta = delta,add.crit.delta=FALSE)
\end_layout

\begin_layout Plain Layout

mat.s  = mat1
\end_layout

\begin_layout Plain Layout

mat.s[,"Ue"]= mat1[,"Ue"]+mat2[,"Ue"]
\end_layout

\begin_layout Plain Layout

# Draw the different matrices
\end_layout

\begin_layout Plain Layout

ylim = range(c(mat.s[,"Ue"],mat.b[,"Ue"]))
\end_layout

\begin_layout Plain Layout

plot(mat.b[,"delta"],mat.b[,"Ue"],col="blue",type="l",
\end_layout

\begin_layout Plain Layout

     main="Single Market vs Multi Market Collusion",
\end_layout

\begin_layout Plain Layout

     xlab="delta",ylab="Ue",ylim=ylim)
\end_layout

\begin_layout Plain Layout

lines(mat.s[,"delta"],mat.s[,"Ue"],col="red",lty=1)
\end_layout

\begin_layout Plain Layout

lines(mat.b[,"delta"],mat.b[,"Ue"],col="blue",lty=2)
\end_layout

\begin_layout Plain Layout

lines(mat1[,"delta"],mat1[,"Ue"],col="green",lty=2)
\end_layout

\begin_layout Plain Layout

lines(mat2[,"delta"],mat2[,"Ue"],col="lightgreen",lty=2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
We find that even though we already have side payments, multi-market contact
 can still increase collusive profits.
 This is the case for those discount factors for which in the single market
 with high transportation costs perfect collusion can be achieved but not
 in the single market with low transportation costs.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename hotelling_multi_vs_single.eps
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Added collusive profits in the two separate markets vs profits under multi-marke
t collusion
\begin_inset CommandInset label
LatexCommand label
name "fig:single vs multi market"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Imperfect Public Monitoring
\end_layout

\begin_layout Standard
This part illustrates how the toolbox can be used to solve infinitely repeated
 games with imperfect public monitoring and monetary transfers.
 So far, I have only implemented our algorithm that characterize the payoff
 set for the case that money burning is possible, but not yet the algorithm
 described in Section 6 of Goldluecke & Kranz (2010) that deals with the
 case of no money burning.
\end_layout

\begin_layout Section
A Noisy Prisoners' Dilemma Game
\begin_inset CommandInset label
LatexCommand label
name "sec:Noisy PD Game"

\end_inset


\end_layout

\begin_layout Standard
To illustrate how the package repgame can solve repeated games with imperfect
 public monitoring, let us first consider the noisy prisoners' dilemma game
 that has been analytically solved in Goldluecke & Kranz (2010).
 There are two players who can choose in each period to either cooperate
 (C) or defect (D).
 Expected payoffs in the stage game are given by the following normalized
 payoff matrix:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
D
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
1,1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
-s,1+d
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
1+d,-s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
0,0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align left
with 
\begin_inset Formula $d,s>0$
\end_inset

 and 
\begin_inset Formula $d-s<1$
\end_inset

.
 Players do not publicly observe the played action profile, but only a signal
 
\begin_inset Formula $y$
\end_inset

 that can take 4 different values: 
\begin_inset Formula $y_{C}$
\end_inset

,
\begin_inset Formula $y_{D}$
\end_inset

,
\begin_inset Formula $y_{1}$
\end_inset

 and 
\begin_inset Formula $y_{2}$
\end_inset

.
 The probability distribution of the signal 
\begin_inset Formula $\phi(y|a)$
\end_inset

 depends on the played action profile and is described in the following
 table
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\phi(y|a)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
(C,C)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
(C,D)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
(D,C)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(D,D)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula $y_{C}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula $1-λ-2α$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula $1-λ-μ-2α-β$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula $1-λ-μ-2α-β$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1-\psi$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula $y_{D}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula $λ$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula $λ+μ$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula $λ+μ$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\psi$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula $α$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula $α$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula $α+β$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula $α$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula $α+β$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula $α$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
with 
\begin_inset Formula $0<λ\leqλ+μ$
\end_inset

 and 
\begin_inset Formula $0<α\leqα+β$
\end_inset

 and 
\begin_inset Formula $1-λ-μ-2α-β\geq0$
\end_inset

.
 To interpret the signal structure, assume mutual cooperation (C,C) shall
 be implemented in the static problem.
 The signal 
\begin_inset Formula $y_{D}$
\end_inset

 is an anonymous indicator for defection: 
\begin_inset Formula $y_{D}$
\end_inset

 becomes more likely if some player unilaterally defects but its probability
 distribution does not depend on the identity of the deviator.
 The parameter 
\begin_inset Formula $\lambda$
\end_inset

 can be interpreted as the probability of a type-one error, i.e.
 the probability that 
\begin_inset Formula $y_{D}$
\end_inset

 is observed even if no player defected.
 The parameter 
\begin_inset Formula $\mu$
\end_inset

 measures by how much the likelihood of 
\begin_inset Formula $y_{D}$
\end_inset

 increases if some player unilaterally deviates.
 The signal 
\begin_inset Formula $y_{i}$
\end_inset

 is an indicator for unilateral defection by player 
\begin_inset Formula $i$
\end_inset

.
 Like 
\begin_inset Formula $\lambda$
\end_inset

, the parameter 
\begin_inset Formula $\alpha$
\end_inset

 can be interpreted as the probability of a type-one error, i.e.
 the probability to wrongly get a signal for unilateral defection of player
 
\begin_inset Formula $i$
\end_inset

.
 Similar to 
\begin_inset Formula $\mu$
\end_inset

, the parameter 
\begin_inset Formula $\beta$
\end_inset

 measures by how much the likelihood of 
\begin_inset Formula $y_{i}$
\end_inset

 increases if player 
\begin_inset Formula $i$
\end_inset

 unilaterally deviates from mutual cooperation.
 
\end_layout

\begin_layout Standard
The following function initializes such a Noisy PD game:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

init.noisy.pd.game = function(d,s,lambda,mu,alpha,beta,psi) {
\end_layout

\begin_layout Plain Layout

  store.objects("init.noisy.pd.game")
\end_layout

\begin_layout Plain Layout

  # restore.objects("init.noisy.pd.game")
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  # Payoff matrix of player 1 (that of player 2 is symmetric)
\end_layout

\begin_layout Plain Layout

  g1 = matrix(c(
\end_layout

\begin_layout Plain Layout

    1,    -s,
\end_layout

\begin_layout Plain Layout

    1+d,   0),2,2,byrow=TRUE)
\end_layout

\begin_layout Plain Layout

  lab.ai = c("C","D")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

  # Create phi.mat, which stores the signal distributions
\end_layout

\begin_layout Plain Layout

  prob.yC = c(1-2*alpha-lambda, 1-2*alpha-lambda-mu-beta,
\end_layout

\begin_layout Plain Layout

              1-2*alpha-lambda-mu-beta, 1-psi)
\end_layout

\begin_layout Plain Layout

                            
\end_layout

\begin_layout Plain Layout

  phi.mat = matrix(c(
\end_layout

\begin_layout Plain Layout

    #CC       CD          DC         DD 
\end_layout

\begin_layout Plain Layout

    prob.yC,                                #yC
\end_layout

\begin_layout Plain Layout

    lambda,   lambda+mu,  lambda+mu , psi,  #yD
\end_layout

\begin_layout Plain Layout

    alpha,    alpha,      alpha+beta, 0,    #y1
\end_layout

\begin_layout Plain Layout

    alpha,    alpha+beta, alpha     , 0     #y2
\end_layout

\begin_layout Plain Layout

  ), 4,4,byrow=TRUE)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  lab.y = c("yC","yD","y1","y2")
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  m=init.game(g1=g1,phi.mat=phi.mat, symmetric=TRUE, 
\end_layout

\begin_layout Plain Layout

              lab.ai = lab.ai,lab.y=lab.y, name="Noisy PD")
\end_layout

\begin_layout Plain Layout

  m
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The matrix 
\family typewriter
phi.mat
\family default
 has as many rows as signals and as many columns as action profiles.
 So 
\family typewriter
phi.mat[y,a]
\family default
 denotes the probability that signal 
\family typewriter
y
\family default
 is realized if action profile 
\family typewriter
a
\family default
 is played.
 The following code initializes one noisy PD game, solves the model and
 draws two different plots of the solution.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

d=1;s=1.5;lambda=0.1;mu=0.2;alpha=0.1;beta=0.2;psi = 1
\end_layout

\begin_layout Plain Layout

m = init.noisy.pd.game(d,s,lambda,mu,alpha,beta,psi)
\end_layout

\begin_layout Plain Layout

m = solve.game(m)
\end_layout

\begin_layout Plain Layout

plot(m,xvar="L",yvar=c("Ue","V"),lwd=2)
\end_layout

\begin_layout Plain Layout

plot(m,xvar="delta",delta.seq=seq(0.5,1,by=0.001),
\end_layout

\begin_layout Plain Layout

     yvar=c("Ue","V"),lwd=2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first plot shows the joint equilibrium and punishment payoffs as function
 of the totally available liquidity 
\begin_inset Formula $L$
\end_inset

, the second plot as function of the discount factor 
\begin_inset Formula $\delta$
\end_inset

 (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:payoffs_noisypd"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename noisypd_L.eps
	scale 60

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename noisypd_delta.eps
	scale 60

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Payoffs of the repeated Noisy PD Game
\begin_inset CommandInset label
LatexCommand label
name "fig:payoffs_noisypd"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
For readers who are familiar with our theoretical paper, let me explain
 more on the structure of optimal equilibria.
 Information about optimal action plans is stored in 
\family typewriter
m$opt.mat
\family default
.
 Let us look at some of its columns:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

m$opt.mat[,c("L","delta","Ue","V","v1","v2","opt","helper")]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
\begin_inset Note Note
status collapsed

\begin_layout LyX-Code
                    L     delta  Ue V v1 v2 opt helper
\end_layout

\begin_layout LyX-Code
(D|D),(D|D)  0.000000 0.0000000 0.0 0  0  0   1      0
\end_layout

\begin_layout LyX-Code
---          2.142857 1.0000000 0.0 0  0  0   0      1
\end_layout

\begin_layout LyX-Code
(C|D),(D|D)  2.142857 0.8108108 0.5 0  0  0   0      0
\end_layout

\begin_layout LyX-Code
---          5.000000 0.9090909 0.5 0  0  0   0      1
\end_layout

\begin_layout LyX-Code
(C|C),(D|D)  5.000000 0.7692308 1.5 0  0  0   1      0
\end_layout

\begin_layout LyX-Code
(C|C),(D|D) 10.000000 0.8333333 2.0 0  0  0   1      0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The row names indicate the optimal action plan.
 Since the game is symmetric, only the optimal equilibrium action profile
 
\begin_inset Formula $a^{e}$
\end_inset

 and the punishment profile for player 1 
\begin_inset Formula $a^{1}$
\end_inset

 are shown.
 A row with name 
\begin_inset Quotes eld
\end_inset

---
\begin_inset Quotes erd
\end_inset

 corresponds to a helper point that describes the end of a horizontal line
 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:payoffs_noisypd"

\end_inset

 (left).
 This means that the action plan remains optimal in the corresponding liquidity
 range and joint equilibrium payoffs and punishment payoffs remain constant
 (i.e.
 there is no money burning).
 After row 5 there is no helper point, which indicates that there is a segment
 between L=5 and L=10, in which 
\begin_inset Formula $U^{e}$
\end_inset

 linearly increases in 
\begin_inset Formula $L$
\end_inset

.
 Payoffs increase because less money burning is required in the static problem
 if more joint liquidity becomes available.
 In the optimal stationary equilibrium corresponding to row 5, mutual cooperatio
n 
\begin_inset Formula $(C,C)$
\end_inset

 will be played on the equilibrium path, but in expectation 
\begin_inset Formula $2-1.5=0.5$
\end_inset

 units of money will be burned every round.
 Row 6 corresponds to an optimal equilibrium with the same action plan but
 no money burning.
\end_layout

\begin_layout Standard
The column 
\family typewriter
opt
\family default
 indicates whether the action plan that is optimal for the given liquidity
 L is indeed an optimal action plan for some discount factor 
\begin_inset Formula $\delta$
\end_inset

.
 In our example, row 3 with 
\begin_inset Formula $a^{e}=(C,D)$
\end_inset

 is not optimal for any discount factor, since it has a higher critical
 discount factor 
\begin_inset Formula $\delta^{*}=0.81$
\end_inset

 than row 6 with 
\begin_inset Formula $\delta=0.77$
\end_inset

.
 Thus, if you look at the right hand side plot of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:payoffs_noisypd"

\end_inset

, you will find that the joint payoff of 0.5 associated with the third row
 does not appear.
\end_layout

\begin_layout Exercise
Perform some graphical comparative statics with respect to the different
 parameters of the model (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Analysing-comparative-statics"

\end_inset

) and compare the optimal equilibria with the analytical closed-form solutions
 in Goldluecke & Kranz (2010).
\end_layout

\begin_layout Section
Collusion without observing sales
\end_layout

\begin_layout Standard
The classical paper by Green and Porter (1984) used repeated games to model
 collusion between quantity setting firms that cannot observe other firms
 sales but only publicly observe the realized market prices.
 The realized market price is only a noisy signal of total output, since
 it also depends on an unobservable demand shock.
 Optimal equilibria in this set-up have already been studied by Abreu, Pearce
 and Stachhetti (1986), who exploit the fact that price signals are completely
 uninformative with respect to which firm deviated.
\end_layout

\begin_layout Standard
While the analysis in this Section may therefore not yield many new economic
 insights, I think this class of models is well suited to illustrate how
 to use my toolbox for analyzing discrete approximations of games with imperfect
 monitoring and continuous action spaces.
\end_layout

\begin_layout Subsection
Simple initial example
\end_layout

\begin_layout Standard
In the following exercise you can first explore a very simple variant of
 a model of collusion without observing sales.
\end_layout

\begin_layout Exercise
Consider two firms that can in each period either choose low, medium or
 high output levels.
 Expected payoffs are as in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Simple-Cournot-Game"

\end_inset

 given by:
\end_layout

\begin_deeper
\begin_layout Description
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Firm 2
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $q_{L}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $q_{M}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $q_{H}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $q_{L}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
10,10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
3,15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
0,7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Firm 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $q_{M}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
15,3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
7,7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
-4,5 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $q_{H}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
7,0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
5,-4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
-15,-15
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Exercise
Firms cannot observe other firms' past output level, but only observe a
 publicly realized market price.
 Assume the realized price can take only two levels 
\begin_inset Formula $p\in\{p_{L},p_{H}\}$
\end_inset

.
 Assume 
\begin_inset Formula $q_{L}=1$
\end_inset

, 
\begin_inset Formula $q_{M}=2$
\end_inset

, and 
\begin_inset Formula $q_{H}=3$
\end_inset

 and let the probability of a low price be given by
\end_layout

\begin_layout Exercise
\begin_inset Formula 
\[
Pr(p=p_{L}|(q_{1},q_{2}))=(q_{1}+q_{2})\Delta
\]

\end_inset


\end_layout

\begin_layout Exercise
where 
\begin_inset Formula $\Delta$
\end_inset

 is a parameter with 
\begin_inset Formula $0<\Delta<6\Delta<1$
\end_inset

.
 Write a function that initializes the model.
 Solve the model and investigate the comparative statics w.r.t.
 
\begin_inset Formula $\Delta$
\end_inset

.
 Using the results in our theoretical paper, try to find analytical solutions
 for 
\begin_inset Formula $L(a)$
\end_inset

, 
\begin_inset Formula $U^{e}(L|a)$
\end_inset

 and 
\begin_inset Formula $v_{i}(L|a)$
\end_inset

.
 Compare them with the results from the computer program.
 
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Subsection
Initializing duopolies with larger action and signal spaces
\end_layout

\begin_layout Standard
We now illustrate the analysis of repeated games with larger action and
 signal spaces.
 Consider 2 symmetric firms that produce a homogeneous good.
 Production costs are given by a convex, increasing function 
\begin_inset Formula $c(q_{i})$
\end_inset

 and each firm has the same capacity limit 
\begin_inset Formula $q_{max}$
\end_inset

.
 The market demand function shall be given by 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
D(P) & = & e^{s}D_{0}(P).
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $D_{0}(P)$
\end_inset

 is a deterministic component of the demand function and 
\begin_inset Formula $s$
\end_inset

 is a random variable that measures the market size and follows some distributio
n with c.d.f.
 
\begin_inset Formula $F_{s}(s)$
\end_inset

.
 We assume that 
\begin_inset Formula $D(P)$
\end_inset

 is strictly decreasing.
 The inverse demand function, which depends on the totally produced quantity
 
\begin_inset Formula $Q=q_{1}+q_{2}$
\end_inset

 and the realized market size 
\begin_inset Formula $s$
\end_inset

, is then given by 
\begin_inset Formula 
\[
P(Q,s)=D_{0}^{-1}\left(e^{-s}Q\right).
\]

\end_inset


\end_layout

\begin_layout Standard
In the action stage, firms simultaneously choose quantities they bring to
 the market without knowing the realization of the total market demand 
\begin_inset Formula $s$
\end_inset

.
 The distribution of market prices given total production 
\begin_inset Formula $Q$
\end_inset

 is given by
\begin_inset Formula 
\begin{eqnarray*}
F_{p}(p|Q) & = & Pr\left\{ P(Q,s)\leq p\right\} \\
 & = & Pr\left\{ e^{-s}Q\leq D_{0}(p)\right\} \\
 & = & F_{s}\left(log\left(\frac{Q}{D_{0}(p)}\right)\right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
If we do not allow for negative demand and negative market prices, the formula
 gets adapted as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
F_{p}(p|Q)=\begin{cases}
1 & \mbox{if \ensuremath{p\geq P_{max}}}\\
F_{s}\left(log\left(\frac{Q}{D_{0}(p)}\right)\right) & \mbox{if \ensuremath{0\leq p\leq P_{max}}}\\
0 & \mbox{if \ensuremath{p<0}}
\end{cases}\label{eq:Fp_discretization}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $P_{max}$
\end_inset

 is the choke price at which demand gets zero, i.e.
 
\begin_inset Formula $D_{0}(P_{max})=0.$
\end_inset


\end_layout

\begin_layout Example*
For example assume the deterministic component of the demand function is
 linear:
\end_layout

\begin_layout Example*
\begin_inset Formula 
\begin{eqnarray*}
D_{0}(P) & = & max\left\{ 0,\alpha-\beta P\right\} 
\end{eqnarray*}

\end_inset

The choke price is then given by 
\begin_inset Formula $P_{max}=\frac{\alpha}{\beta}$
\end_inset

 and the distribution of market prices is given by formula (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Fp_discretization"

\end_inset

).
\end_layout

\begin_layout Standard
The toolbox cannot directly solve repeated games that have continuous action
 or signal space.
 We therefore have to discretize both.
 To discretize each firm's action space, we can simply choose some finite
 grid of quantities between 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $q_{max}$
\end_inset

.
 There are different methods to discretized a continuous signal distribution.
\end_layout

\begin_layout Standard
The toolbox contains a function that performs discretization according to
 the following method.
 First, we specify a finite grid of 
\begin_inset Formula $M$
\end_inset

 price signals 
\begin_inset Formula $\left\{ y_{1},...,y_{M}\right\} $
\end_inset

 with 
\begin_inset Formula $0=y_{1}<...<y_{M}$
\end_inset

.
 If a choke price 
\begin_inset Formula $P_{max}$
\end_inset

 exists, we set 
\begin_inset Formula $y_{M}=P_{max}$
\end_inset

.
 The probability weight on each price signal 
\begin_inset Formula $y_{m}$
\end_inset

 as function of total produced output 
\begin_inset Formula $Q$
\end_inset

 shall be given by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\phi(y_{m}|Q) & = & \begin{cases}
F_{p}(y_{m})+\frac{F_{p}(y{}_{m+1})-F_{p}(y_{m})}{2} & \mbox{if \ensuremath{m=1}}\\
\frac{F_{p}(y_{m})-F_{p}(y_{m-1})}{2}+\frac{F_{p}(y_{m+1})-F_{p}(y_{m})}{2} & \mbox{if \ensuremath{1<m<M}}\\
\frac{F_{p}(y_{m})-F_{p}(y_{m-1})}{2}+1-F_{p}(y_{m}) & \mbox{if \ensuremath{m=M}}
\end{cases}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Basically, the probability mass between two adjacent signals is divided
 equally between the two signals.
 
\end_layout

\begin_layout Standard
The following code initializes and solves a repeated game in this class.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# Require global parameters to be set
\end_layout

\begin_layout Plain Layout

# D0.fun, p.max, F.s = F.s, cost.fun = cost.fun,q.max = q.max
\end_layout

\begin_layout Plain Layout

# Either nq=nq or q.seq=NULL     
\end_layout

\begin_layout Plain Layout

init.payoffs.green.porter = function(make.q.seq=TRUE) {
\end_layout

\begin_layout Plain Layout

  #store.objects()
\end_layout

\begin_layout Plain Layout

  # restore.objects("init.payoffs.green.porter")
\end_layout

\begin_layout Plain Layout

                                          
\end_layout

\begin_layout Plain Layout

  # Generate the distribution function for prices F.p
\end_layout

\begin_layout Plain Layout

  # The assignment <<- stores F.p in the global environment 
\end_layout

\begin_layout Plain Layout

  F.p <<- function(p,Q) {
\end_layout

\begin_layout Plain Layout

    x = F.s(log(Q / D0.fun(p)))
\end_layout

\begin_layout Plain Layout

    x[p >= p.max] == 0
\end_layout

\begin_layout Plain Layout

    x
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  # Action space of each firm (we assume firms are symmetric)
\end_layout

\begin_layout Plain Layout

  if (make.q.seq) {
\end_layout

\begin_layout Plain Layout

    q.seq <<- seq(0,q.max,length=nq)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

  # Generate function that calculates expected payoffs for
\end_layout

\begin_layout Plain Layout

  # each action profile
\end_layout

\begin_layout Plain Layout

  # The function performs a very fine discretization of 
\end_layout

\begin_layout Plain Layout

  # the distribution F.p to approximate expected payoffs
\end_layout

\begin_layout Plain Layout

  g.fun = function(qm) {
\end_layout

\begin_layout Plain Layout

    store.objects("g.fun")
\end_layout

\begin_layout Plain Layout

    #restore.objects("g.fun")
\end_layout

\begin_layout Plain Layout

     
\end_layout

\begin_layout Plain Layout

    Q = rowSums(qm)
\end_layout

\begin_layout Plain Layout

    g = matrix(0,NROW(qm),2)
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

    # Calculate expected profits for every action profile
\end_layout

\begin_layout Plain Layout

    # The loop takes some time, since calculation of an expected price
\end_layout

\begin_layout Plain Layout

    # uses numerical integration for every level of Q
\end_layout

\begin_layout Plain Layout

    for (r in 1:NROW(qm)) {
\end_layout

\begin_layout Plain Layout

       Ep = calc.mean.from.F.fun(F.p,Q=Q[r],x.min=0,x.max=p.max)
\end_layout

\begin_layout Plain Layout

       g[r,] = Ep * qm[r,] - cost.fun(qm[r,])
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    # Manually correct the case that no firm produces anything
\end_layout

\begin_layout Plain Layout

    if (Q[1]==0) {
\end_layout

\begin_layout Plain Layout

      g[1,] = c(0,0)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    g
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

  m = init.game(g.fun=g.fun, action.val = q.seq, symmetric=TRUE,
\end_layout

\begin_layout Plain Layout

        name="Green-Porter with Optimal Penal Codes")
\end_layout

\begin_layout Plain Layout

  return(m)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

init.signals.green.porter = function(m=m) {
\end_layout

\begin_layout Plain Layout

  qm = m$action.val.mat
\end_layout

\begin_layout Plain Layout

  Q=rowSums(qm)
\end_layout

\begin_layout Plain Layout

  y.val <<- seq(0,p.max,length=ny)
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

  # Calculate the F.p at every signal y
\end_layout

\begin_layout Plain Layout

  # mapply and apply work similar than Vecorize
\end_layout

\begin_layout Plain Layout

  F.y = mapply(F.p,Q=Q,MoreArgs=list(p=y.val))
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

  # Assign probability weight according to the
\end_layout

\begin_layout Plain Layout

  # discretization procedure explained in the tutorial
\end_layout

\begin_layout Plain Layout

  phi.mat = apply(F.y,2,discretize.given.F.vec)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  # We have to manually correct the price distribution if 
\end_layout

\begin_layout Plain Layout

  # no firm produces anything
\end_layout

\begin_layout Plain Layout

  phi.mat[,Q==0] = c(rep(0,ny-1),1)
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

  # Initialize the signal distribution for the model m
\end_layout

\begin_layout Plain Layout

  m = set.phi.mat(m,phi.mat,lab.y = paste("y",y.val,sep=""))
\end_layout

\begin_layout Plain Layout

  m$y.val = y.val
\end_layout

\begin_layout Plain Layout

  return(m)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

# Initialize parameters
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

# Deterministic part of demand function
\end_layout

\begin_layout Plain Layout

alpha = 100; beta = 1;
\end_layout

\begin_layout Plain Layout

D0.fun = function(P) {alpha-beta*P}
\end_layout

\begin_layout Plain Layout

p.max = alpha / beta
\end_layout

\begin_layout Plain Layout

q.max = alpha
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

# Distribution of market size
\end_layout

\begin_layout Plain Layout

mean.s = 0; sigma.s = 0.2
\end_layout

\begin_layout Plain Layout

F.s = function(x) {pnorm(x,mean.s,sigma.s)}
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

# Cost function
\end_layout

\begin_layout Plain Layout

MC = 10
\end_layout

\begin_layout Plain Layout

cost.fun = function(q) {MC*q}
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

# Number of actions per firm and number of signals
\end_layout

\begin_layout Plain Layout

nq = 51;
\end_layout

\begin_layout Plain Layout

ny = 21;
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

# Initialize model with perfect monitoring
\end_layout

\begin_layout Plain Layout

m.pm = init.payoffs.green.porter()
\end_layout

\begin_layout Plain Layout

m.pm$name = "Cournot with Payments & Optimal Penal Codes" 
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

# Transform into a model with imperfect monitoring
\end_layout

\begin_layout Plain Layout

m = init.signals.green.porter(m.pm)
\end_layout

\begin_layout Plain Layout

m$name = "Green-Porter with Payments & Optimal Penal Codes"
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Depending on your reference point, it may look like a lot of code, but I
 hope together with the comments it is quite intuitive what is going on.
 
\end_layout

\begin_layout Subsection
Solving the model and analysing the solution
\end_layout

\begin_layout Standard
To solve the model above, we can simply type.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# Solve the models for perfect and imperfect monitoring
\end_layout

\begin_layout Plain Layout

m.pm = solve.game(m.pm)
\end_layout

\begin_layout Plain Layout

m = solve.game(m, ignore.ae = m$action.val[,1]>m$action.val[,2])
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The last line solves the model with imperfect monitoring.
 The parameter 
\family typewriter
ignore.ae
\family default
 of the function 
\family typewriter
solve.model
\family default
 can be used to ignore certain action profiles as candidates for optimal
 equilibrium action profiles.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
For games with imperfect public monitoring, the parameters ignore.ae or ignore.ai
 can play similar roles than the link functions link.fun.ae and link.fun.ai
 used in the analyze of repeated games with perfect monitoring with large
 action spaces (see Sections 5 and 6).
 The difference in the two approaches is due to the fact that for games
 with imperfect monitoring, we always have to specify the whole grid of
 action profiles while for games with perfect monitoring we can use an algorithm
 that locally refines grids.
\end_layout

\end_inset

 Since the stage game is symmetric, we can assume w.l.o.g.
 that player 1 produces the same amount or weakly more than player 2 on
 the equilibrium path.
 Ignoring the action profiles where player 2 produces more, speeds up calculatio
n.
 Still, it takes some seconds to solve the model.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsubsection*
The graphical illustration of the solution process
\end_layout

\begin_layout Plain Layout
During the process the toolbox shows you some dynamic graphical representation
 of the solution process.
 A screen-shot is shown below:
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename greenporter_duringsolve.eps
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
The title first shows the actual state that is solved: v1 stands for player
 1's punishment state.
 In brackets we find the total number of action profiles that have to be
 checked (the second number are all action profiles, the first number is
 the number of action profiles who have a best-reply payoff below some Nash
 equilibrium of the stage game).
 The grey box on the top-right corner shows how many action profiles have
 already been investigated (205), and for how many of those action profiles
 one or more linear programs had to be solved (here 132).
 The remaining 205-132=72 action profiles had been quickly dismissed as
 candidates for optimal punishment profiles by using the methods described
 in the appendix of our theoretical paper.
 The red points and line show the lower envelope of player 1's punishment
 payoffs 
\begin_inset Formula $v_{1}(L)$
\end_inset

 from the 205 action profiles that have already been solved.
 The green line shows the relevant part of the function 
\begin_inset Formula $v_{1}(L|a)$
\end_inset

 from the last action profile 
\begin_inset Formula $a$
\end_inset

 that possible could improve the envelope.
 The yellow and orange dots indicate action profiles 
\begin_inset Formula $a'$
\end_inset

 that were inspected after 
\begin_inset Formula $a$
\end_inset

 and could be dismissed before 
\begin_inset Formula $v_{1}(L|a')$
\end_inset

 had to be calculated.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The yellow and orange dots correspond to two different attempts to check
 whether an action profile could be dismissed.
 For dots above the red line, not even the liquidity requirement had to
 be calculated.
 For details look at the source code.
\end_layout

\end_inset

 Towards the end of the computation, you will see large clouds of orange
 dots, which indicate that many action profiles can be dismissed quickly.
 Admittedly, these plots are not very artful, but I felt that some visualization
 is helpful to get a feeling of what is going on.
\end_layout

\begin_layout Plain Layout
If during the solution you click on the text window, you can see reports
 from the linear programming solver.
 You may also get some warnings that some of the many conducted linear optimizat
ion problems was plaqued by numerically instability of no solution could
 be found.
 The program then tries a different method (like dual simplex) and the message
 should tell you whether that worked.
 If the warning persist, you have to decide whether you can ignore the warning
 or not (the description of the actual linear optimization problem where
 the warning occured can be found above the warning).
 For example, it can well be the case that you have a stage game where some
 action profiles can never be implemented.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To compare the equilibrium payoffs under imperfect and perfect monitoring,
 we can type
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

plot.compare.models(m.pm,m,xvar="delta",yvar="Ue",
\end_layout

\begin_layout Plain Layout

        m1.name = "Cournot",m2.name="Green-Porter Style",
\end_layout

\begin_layout Plain Layout

        legend.pos ="bottomright")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The resulting plot is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:payoffs_greenporter"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename green_porter vs cournot.eps
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Joint equilibrium and punishment payoffs of the modified Green-Porter model
 and the case with perfect monitoring
\begin_inset CommandInset label
LatexCommand label
name "fig:payoffs_greenporter"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We see how much cooperation can be facilitated if firms can perfectly monitor
 each others actions.
 It is thus not-surprising that in reality effective monitoring technologies
 are crucial for the stability and profitability of cartels.
\end_layout

\begin_layout Standard
For the case of imperfect monitoring, the joint monopoly profit cannot be
 achieved by the cartel even as the discount factor 
\begin_inset Formula $\delta$
\end_inset

 approaches 
\begin_inset Formula $1$
\end_inset

, This is a well known result.
 Formally, the folk theorem does not hold because the full dimensionality
 criterion of Fudenberg, Levine and Maskin (1994) is not satisfied if firms
 only observe price signals.
 A rough intuition is that market prices contain no information about which
 firm potentially deviated from the agreement.
 Realizations of low market prices therefore have to be punished with jointly
 inefficient continuation play.
 
\end_layout

\begin_layout Standard
If you type 
\family typewriter
m$opt.mat
\family default
, you see the structure of optimal action plans for all discount factors.
 The list is quite long and therefore not easy to comprehend.
 To get some graphical representation type:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

ret = levelplot.rep(m=m,z=m$G,main="G and opt.
 action plan",
\end_layout

\begin_layout Plain Layout

  focus=2,cuts=100, xlab="q1",ylab="q2", identify=NULL,
\end_layout

\begin_layout Plain Layout

  col.nash="purple",col.br1 = "green", col.br2 = "greenyellow",
\end_layout

\begin_layout Plain Layout

  col.ae = "blue", col.a1 = "red")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Which draws a levelplot of maximal stage game payoffs and adds some information
 about the optimal action plans.
 The resulting plot is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:levelplot_greenporter_G"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename green_porter_levelplot G (1).eps
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Levelplot of joint stage game payoffs and information about optimal action
 plans
\begin_inset CommandInset label
LatexCommand label
name "fig:levelplot_greenporter_G"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The green line show player 1 and 2's best reply functions in the stage game
 and the purple dot the Nash equilibrium of the stage game.
 The blue dots show the optimal equilibrium action profiles for different
 discount factor and the red dots depict optimal punishment profiles.
 The order of the profiles can be somewhat disentangled by the lines that
 connect the different optimal profiles.
 The nearer a profile is to the stage game Nash equilibrium, the lower is
 the discount factor for which the action profile is optimal.
\end_layout

\begin_layout Subsection
Optimal equilibrium state action profiles
\end_layout

\begin_layout Standard
Let us investigate in more detail the optimal equilibrium state action profiles.
 To get a zoomed picture of the relevant range of actions, paste the following
 code:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

ret = levelplot.rep(m=m,z=m$G,main="G and opt.
 ae",
\end_layout

\begin_layout Plain Layout

  focus=2,cuts=100,xlab="q1",ylab="q2", identify="Ue",
\end_layout

\begin_layout Plain Layout

  xlim=c(-1,35),ylim=c(20,56), zlim=c(500,2000),
\end_layout

\begin_layout Plain Layout

  col.nash="purple",col.br1 = NA, col.br2 = NA,
\end_layout

\begin_layout Plain Layout

  col.ae = "blue", col.a1 = NA)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The parameters 
\family typewriter
xlim
\family default
 and 
\family typewriter
ylim
\family default
 specify the range of player 1 and player 2's action levels for which the
 plot shall be drawn.
 The parameter 
\family typewriter
zlim
\family default
 can be used to reduce the range of over which the grey scale for G will
 be defined.
 By setting 
\family typewriter
col.br1 = NA
\family default
, the stage game best replies of player 1 will not be drawn (similar for
 the other parameters).
 The parameter 
\family typewriter
identify="Ue"
\family default
, allows you to interactively click on the levelplot to select specific
 action profiles and compare the form of the function 
\begin_inset Formula $U^{e}(L|a)$
\end_inset

 for the different selected points.
 Clicking once on a point opens a new graphic window that shows this plot
 (the new graphic window may open below the actual window, you may have
 to move the current window to see the new one).
 Note that the R prompt does not take any commands while in the point selection
 mode.
 To leave this mode, press the right mouse button on the levelplot and say
 stop or press the red stop button in your R Gui.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:green_porter_state_e"

\end_inset

 illustrates the level plot and the function 
\begin_inset Formula $U^{e}(L|a)$
\end_inset

 for 4 selected points:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename green_porter_levelplot G (2).eps
	scale 60

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename green_porter_Ue from Levelplot.eps
	scale 60

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Investigating the structure of optimal equilibrium action profiles 
\begin_inset Formula $a^{e}$
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:green_porter_state_e"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
While the fourth point selected point has a joint output of 
\begin_inset Formula $26+28=54$
\end_inset

, the first 3 selected points lie on a line that have the same joint output
 
\begin_inset Formula $q_{1}+q_{2}=56$
\end_inset

 and thus also the same joint stage game payoff 
\begin_inset Formula $G(a)$
\end_inset

.
 The right hand side of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:green_porter_state_e"

\end_inset

 confirms that they also have the same functional form for 
\begin_inset Formula $U^{e}(L|a)$
\end_inset

 with the exception that the more symmetric action profiles have a lower
 liquidity requirement.
 (It is easier to see this if you click yourself!).
\end_layout

\begin_layout Standard
You probably asked yourself the following question: What is the reason that
 the equilibrium points wiggle around like they do and why are so often
 asymmetric action profiles optimal? I below I suggest a list of possible
 answers (the plot in the right hand side of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:green_porter_state_e"

\end_inset

 may already suggest which ones are more likely to be true):
\end_layout

\begin_layout Enumerate
There is an error either in the way the model is set-up or in the toolbox.
 (While the toolbox already went through quite some debugging, it is still
 in development stage and errors are well possible.)
\end_layout

\begin_layout Enumerate
For a given discount factor, several action profiles can be optimal.
 The algorithm does not necessarily pick the most symmetric ones for every
 discount factor and the wiggling around may simply be due to indifference.
\end_layout

\begin_layout Enumerate
The reason for the wiggling around is connected to the fact that we consider
 a finite approximation of the originally continuous stage game.
 It could be the case that in the continuous game, fully symmetric action
 profiles are optimal but not in the finite approximation.
 For example there can exist some asymmetric profiles that correspond to
 certain level of average outputs 
\begin_inset Formula $\frac{q_{1}+q_{2}}{2}$
\end_inset

, but on the finite grid no symmetric profile with the same average output
 exists.
\end_layout

\begin_layout Enumerate
Even in the continuous version of the game, it is an inherent characteristic
 that asymmetric action profiles are optimal on the equilibrium path.
 For example, one might think that perhaps the asymmetric incentives to
 deviate under an asymmetric equilibrium profile might allow for more efficient
 asymmetric punishments if low prices are observed.
\end_layout

\begin_layout Standard
In the end one has to resolve the question whether asymmetric equilibrium
 action profiles can be optimal by a theoretical proof, but the toolbox
 can be helpful in making sensible conjectures and get intuition which result
 might be more likely to be true and why that would be the case.
 The plots in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:green_porter_state_e"

\end_inset

, are so far still suggesting that in a continuous version of the game,
 symmetric profiles might always be optimal (in particular, since they have
 a lower liquidity requirement).
\end_layout

\begin_layout Standard
To get more insight you can click around a bit more or paste the following
 code:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

ai.mat = get.ai.mat(m)
\end_layout

\begin_layout Plain Layout

ignore.ae = !(ai.mat[,1]==ai.mat[,2] |
\end_layout

\begin_layout Plain Layout

              ai.mat[,1] == (ai.mat[,2]-1) ) 
\end_layout

\begin_layout Plain Layout

m.sym.ae = solve.game(m,ignore.ae=ignore.ae)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This code solves the model with the restriction that only symmetric action
 profiles (and profiles that are one action unit left of the main diagonal)
\begin_inset Foot
status open

\begin_layout Plain Layout
We add these shifted profiles to account for the effect described under
 point 3: off-diagonal elements can have total contribution levels that
 in the discretized game are not obtained by any fully symmetric profile.
\end_layout

\end_inset

 are considered for equilibrium action profiles.
 The matrix 
\family typewriter
ai.mat
\family default
 simply returns the index of each players actions (in comparison to 
\family typewriter
m$action.val.mat
\family default
, which returns the action value, i.e.
 the quantity).
 You can investigate payoffs and optimal action plans of the restricted
 solved model using the methods described above.
 The following command allows direct comparison of the maximal equilibrium
 payoffs of the restricted and unrestricted models:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

plot.compare.models(m,m.sym.ae,xvar="L",yvar="Ue",
\end_layout

\begin_layout Plain Layout

   m1.name = "unrestricted", m2.name = "sym.
 ae",
\end_layout

\begin_layout Plain Layout

   legend.pos  =  "bottomright",identify="Ue")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The resulting plot is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:comparison_greenporter_sym_e"

\end_inset

.
 One can almost see no difference in the maximal joint payoffs for the restricte
d and unrestricted case.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename green_porter_compare_model.eps
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Comparison of equilibrium payoffs solution with symmetric equilibrium actions
 and unrestricted solution
\begin_inset CommandInset label
LatexCommand label
name "fig:comparison_greenporter_sym_e"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Small differences can be due to inaccuracies in calculations with finite
 precision floating point numbers.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
My implementation of the algorithm to calculate upper envelopes only guarantees
 to calculate the upper envelope within some tolerance interval.
 I introduced the tolerance level to make the calculations more robustness
 with respect to inaccuracies of calculations with floating point numbers.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The example thus supports the following conjecture:
\end_layout

\begin_layout Conjecture*
In the symmetric Green-Porter style model with side-payments and continuous
 action and signal spaces, every pure strategy PPE payoff can be implemented
 with stationary equilibria that use symmetric equilibrium action profiles.
\end_layout

\begin_layout Standard
I admit that this conjecture is not very surprising, in particular given
 the results from Abreu, Pearce, Stacchetti (1986)...
 but I wanted to illustrate how the toolbox can help you to form quite educated
 guesses.
\end_layout

\begin_layout Subsection
Punishment States
\end_layout

\begin_layout Standard
Let us now have a closer look at the structure of optimal punishment profiles.
 In Abreu, Pearce & Stacchetti (1986) optimal punishment profiles will be
 symmetric, but this won't be the case in our set-up where we allow for
 observable monetary transfers and money burning.
 This means we can use asymmetric punishments in case a player defects from
 a required payment.
 The following code generates the zoomed levelplot shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:green_porter_state_i"

\end_inset

 (left):
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# Level plots for the punishment state
\end_layout

\begin_layout Plain Layout

ret = levelplot.rep(m=m,z=m$c[,1],main="c1 and opt.a1",
\end_layout

\begin_layout Plain Layout

  focus=0,cuts=100,
\end_layout

\begin_layout Plain Layout

  xlab="q1",ylab="q2", identify="v1",
\end_layout

\begin_layout Plain Layout

  xlim=c(-1,35),ylim=c(25,100),
\end_layout

\begin_layout Plain Layout

  col.nash="purple",col.br1 = "green", col.br2 = "greenyellow",
\end_layout

\begin_layout Plain Layout

  col.ae = NA, col.a1 = "red")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us interpret the resulting levelplot.
 Unless discount factors are so low that the optimal punishment profile
 
\begin_inset Formula $a^{1}$
\end_inset

 is the Nash equilibrium of the stage game, firm 2 chooses an output level
 above the Nash equilibrium output and above its best-reply output.
 This makes perfectly sense, since firm 1 is more severely punished if firm
 2 chooses a high output, or more precisely, firm 1's best-reply payoff
 is the lower the higher is firm 2's output.
 Firm 1 always chooses an output weakly below his Nash equilibrium output.
 For intermediate discount factors firm 1's output is below its stage game
 best-reply output.
 However, there is a critical discount factor so that for higher discount
 factors, firm 1 plays a best-reply in its punishment profile.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename green_porter_levelplot for v1.eps
	scale 60

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename green_porter_v1 from Levelplot.eps
	scale 60

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Analyzing the optimal punishment profiles for player 1 in the Green-Porter
 Style Model
\begin_inset CommandInset label
LatexCommand label
name "fig:green_porter_state_i"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
One may wonder whether this structural break is indeed an inherent characteristi
c of optimal punishment profiles or whether similar to the equilibrium action
 profiles there is a broad range of optimal punishment profiles for every
 discount factor and the algorithm just by chance turned out to have selected
 a path with this peculiar structural break.
 By clicking with the left mouse button on the level plot I selected two
 action profiles marked with 1 and 2 in the level plot.
 In both action profiles player 2 chooses an output of 48: in the first
 action profile player 1 plays a stage game best-reply to 48 and the second
 action profile is an optimal punishment profile for player 1.
 The right hand side of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:green_porter_state_i"

\end_inset

 shows the opened plot in which the function 
\begin_inset Formula $v_{1}(L|a)$
\end_inset

 are drawn for the two selected points.
 We find that the second profile (the optimal action profile) has a lower
 liquidity requirement but the first profile (player 1 plays a stage game
 best-reply) can implement lower punishment payoffs.
\end_layout

\begin_layout Standard
The latter observation illustrates Lemma 2 in our theoretical paper: player
 1's cheating payoff 
\begin_inset Formula $c_{1}(a^{1})$
\end_inset

 is the lowest punishment payoff that can ever be implemented with a given
 punishment profile 
\begin_inset Formula $a^{1}.$
\end_inset

 This punishment payoff can always be attained if player 1 plays a stage-game
 best reply.
 Generically, punishment payoffs are strictly above 
\begin_inset Formula $c_{1}(a^{1})$
\end_inset

 if player 1 does not play a stage game best-reply in his punishment profile.
\end_layout

\begin_layout Standard
That the first action profile has a higher liquidity requirement than the
 second action profile may be explained by the following intuition: Since
 quantities are strategic substitutes, a high output of firm 2 can be easier
 sustained if the punished firm 1 chooses a low output.
 There seems to be some convexity in the total liquidity requirement in
 the sense that larger absolute deviations from a firms' best reply are
 increasingly expensive and that therefore points somewhat centered between
 the two best-reply functions can achieve an optimal trade-off between liquidity
 requirement and reducing player 1's punishment payoff.
 The following code generates the plot in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:green_porter_L_state_i"

\end_inset

 that shows graphically how liquidity requirements are lower between the
 two best reply-functions (levels shown in blue correspond to action plans
 for which the liquidity requirement has not been calculated when the model
 has been solved).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# Show liquidity requirements
\end_layout

\begin_layout Plain Layout

ret = levelplot.rep(m=m,z=m$L,main="L",focus=-3,cuts=100,
\end_layout

\begin_layout Plain Layout

  xlab="q1",ylab="q2", identify="v1",
\end_layout

\begin_layout Plain Layout

  xlim=c(-1,35),ylim=c(25,100),
\end_layout

\begin_layout Plain Layout

  col.nash="purple",col.br1 = "green", col.br2 = "greenyellow",
\end_layout

\begin_layout Plain Layout

  col.ae = NA, col.a1 = NA)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename green_porter_levelplot L for v1.eps
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Liquidity requirements
\begin_inset CommandInset label
LatexCommand label
name "fig:green_porter_L_state_i"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
When the structural break occurs, firm 1 already produces an output of 1
 (lower outputs are forbidden by the non-negativity constraints).
 For larger discount factors lower punishment payoffs seem to be more easily
 implementable in a regime where player 1 plays a best-reply.
 I think this makes intuitive sense.
 The following code can be used to generate Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:green-porter_state_i_model_compare"

\end_inset

, which verifies that restricting player 1 to play a best-reply in his punishmen
t would indeed yield lower punishment payoffs:
\end_layout

\begin_layout LyX-Code
                                        
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

ignore.a1 = (m$g[,1] != m$c[,1])                                        
\end_layout

\begin_layout Plain Layout

m.a1.br1 = solve.game(m,ignore.a1=ignore.a1)
\end_layout

\begin_layout Plain Layout

plot.compare.models(m,m.a1.br1,xvar="L",yvar="v1", x.max=4000,
\end_layout

\begin_layout Plain Layout

                    m1.name="m", m2.name="m1.a1.br1")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename green_porter_compare_model v1.eps
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Punishment payoffs in optimal model and under restriction that firm 1 plays
 a stage game best reply.
\begin_inset CommandInset label
LatexCommand label
name "fig:green-porter_state_i_model_compare"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
For intermediate levels of liquidity, strictly lower punishment payoffs
 can be implemented if the set of player 1's punishment profiles is not
 restricted to action profiles where player 1 plays a best reply.
\end_layout

\begin_layout Subsection
Exercises
\end_layout

\begin_layout Exercise
(Optimal punishment profiles if production costs are very low) Solve a variant
 of the studied oligopoly in Section 6.2 where firms have no production costs.
 Draw a levelplot to illustrate the structure of optimal punishment profiles.
 Explain the result intuitively.
 Now study the structure of optimal equilibria for a sequence of games where
 -ceteris paribus- you slightly increase the constant marginal production
 costs.
 Perform the same analysis for the case of perfect monitoring.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise
(Symmetric punishment profiles) Solve the model under the restriction that
 only symmetric punishment profiles with 
\begin_inset Formula $q_{1}^{i}=q_{2}^{i}$
\end_inset

 can be used (use the ignore.ai parameter).
 Why would you think that the resulting payoff set is the same than under
 optimal contracts without monetary transfers studied by Abreu, Pearce and
 Stachetti (1986)?
\end_layout

\begin_layout Exercise
Also solve the case of perfect monitoring with a restriction to symmetric
 punishment profiles (you can use the parameter ignore.ai in a similar fashion
 as for games with imperfect monitoring or use the framework with link functions
 described in Section 5.3) Why is the resulting equilibrium set larger still
 larger than in Abreu's (1986) analysis of optimal strongly symmetric equilibria
 in repeated Cournot games with perfect monitoring? 
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise
Harrington & Skrzypacz (2007) study a collusion model where firms can make
 observable monetary transfers.
 The structure of the model is inspired by actual behavior of revealed cartels,
 most notably the Lysine and Citric Acids Cartels.
\begin_inset Foot
status open

\begin_layout Plain Layout
Even if you are not an expert on collusion, you might have heard some details
 from the Lysine Cartel from the movie The Informant.
 The movie is based on Kurt Eichenwald's great book with the same name that
 documents the FBI investigations on that case.
\end_layout

\end_inset

 Harrington & Skrzypacz do not consider optimal punishments, but assume
 that if a firm fails to make required monetary transfers the punishment
 is that all firms revert to infinite repetition of the stage game Nash
 equilibrium.
\end_layout

\begin_layout Exercise
Solve our model with the restriction that only the stage game Nash equilibrium
 is allowed as punishment profile.
 Note that the resulting punishment paths are not equal to an infinite repetitio
n of the stage game Nash equilibrium: they have a stick and carrot structure
 where the stage game Nash equilibrium is played only for one period and
 one reverts back to the equilibrium state if all required payments are
 made after this punishment period.
 Why are the resulting punishment payoffs nevertheless the same as if one
 would use a grim-trigger punishment á la Harrington & Skrzypacz?
\end_layout

\begin_layout Exercise
Actually, Harrington & Skrzypacz did not consider a framework with quantity
 setting, but price setting firms and stochastic shocks to realized market
 shares.
 Implement (a discrete approximation) of their game using the toolbox and
 analyze the structure of optimal equilibria and resulting payoff sets.
 
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise
(Sensitivity analysis of discrete approximations) Analyze how sensitive
 the resulting payoff sets are to the chosen discrete approximations of
 the action and signal space.
 Perform comparative statics with respect to the number of actions and signals
 that are used to approximate the continuous game.
 
\end_layout

\begin_layout Section
Auditing
\end_layout

\begin_layout Standard
This Section just contains some first results on an idea I am currently
 working on.
 It shall illustrate how our theoretical results and the toolbox can be
 used to compare in more detail different monitoring technologies that players
 may use to structure their relationship.
\end_layout

\begin_layout Standard
In a repeated oligopoly with perfect monitoring firms can publicly observe
 each others sales.
 Such public signals could, for example, be created by publicly verifiable
 reports on a firm's sales from an external auditor.
 Indeed, we now from the FBI tapes of the Lysine Cartel that the conspiring
 firms, where indeed considering to use external auditors to verify sales
 reports across the cartel members.
 Auditing may not only be relevant for collusion, but also in joint team
 production where under normal circumstances only the resulting success
 or failure of the project is observable, one may use audits to get a public
 signal about each players effort choices.
 Such audit reports may not be evidence enough to base court-enforceable
 contracts upon them, but they may be relevant for the selected continuation
 equilibrium.
 As auditing is expensive, one may not want to audit every period, but rather
 rely on infrequent, randomly triggered auditing.
\end_layout

\begin_layout Standard
Here I want to present a first simple framework that allows to augment any
 repeated game with imperfect public monitoring by a simple auditing structure.
 There shall be an external auditor that performs after each period with
 a fixed probability 
\begin_inset Formula $\pi$
\end_inset

 an audit on all players.
 An audit shall perfectly reveal the chosen actions of all players an make
 it commonly known among the players.
 
\end_layout

\begin_layout Standard
There is no conceptual difficulty to extend any game with imperfect monitoring
 by such an auditing scheme.
 We simply have to extend the old signal space 
\begin_inset Formula $Y$
\end_inset

 to a new signal space 
\begin_inset Formula $\tilde{Y}=Y\times A\cup\{\textrm{Ø}\}$
\end_inset

.
 A new signal is given by 
\begin_inset Formula $\tilde{y}=(y,\alpha)$
\end_inset

 where 
\begin_inset Formula $y$
\end_inset

 indicates the normal signal and 
\begin_inset Formula $\alpha\in A$
\end_inset

 is the action profile reported by the audit and 
\begin_inset Formula $\alpha=\textrm{Ø}$
\end_inset

 indicates that no audit took place.
 The distribution of the new signals is then simply given by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\tilde{\phi}(y,\alpha|a)=\begin{cases}
\phi(y|a)*(1-\pi) & \mbox{if \alpha=\textrm{Ø}}\\
\phi(y|a)*\pi & \mbox{if \alpha=\ensuremath{a}}\\
0 & \mbox{otherwise}
\end{cases}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The only practical drawback is that the signal space can now become very
 large if the original game already had a large signal space.
 Computation time may substantially increase.
\end_layout

\begin_layout Standard
However, there are simply methods to reduce computational complexity.
 Let me explain some of them.
 Since, we have assumed that auditing is perfect and always fully reveals
 the played action profile, the audit report is a sufficient statistic for
 actual behavior, i.e.
 one can ignore the signal 
\begin_inset Formula $y$
\end_inset

 if an audit took place.
 This means that the modified game with signal space 
\begin_inset Formula $\hat{Y}=Y\cup A$
\end_inset

 and signal distribution 
\begin_inset Formula 
\begin{equation}
\hat{\phi}(\hat{y}|a)=\begin{cases}
\phi(\hat{y}|a)*(1-\pi) & \mbox{if \ensuremath{\hat{y}\in Y}}\\
\pi & \mbox{if }\hat{y}=a\\
0 & \mbox{otherwise}
\end{cases}
\end{equation}

\end_inset

 has the same payoff sets than the game specified by 
\begin_inset Formula $\tilde{Y}$
\end_inset

 and 
\begin_inset Formula $\tilde{\phi}$
\end_inset

but considerably less signals.
\end_layout

\begin_layout Standard
We can reduce computational complexity even further.
 Since an audit is perfect, it only matters whether some deviation took
 place or not.
 It is always optimal that a player that was caught to have deviated is
 required to pay the maximum amount he can be induced to be paid 
\begin_inset Formula $\frac{\delta}{1-\delta}(u_{i}-v_{i})$
\end_inset

, independent to which action he did deviate.
 In the static problems that we use to characterize the repeated game, we
 can correspondingly require player 
\begin_inset Formula $i$
\end_inset

 to make the maximum payment 
\begin_inset Formula $\lambda_{i}L$
\end_inset

 if he was found to have unilaterally deviated from the required action
 profile.
 This can be incorporated by a simple modification of the action constraints
 in the static problem.
 The new action constraints with auditing become:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
g_{i}(a)-(1-\pi)E_{y}[p_{i}|a]\geq g_{i}(\hat{a}_{i},a_{-i})-(1-\pi)E_{y}[p_{i}|\hat{a}_{i},a_{-i}]-\pi\lambda_{i}L\label{eq:AC}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
My toolbox allows to directly implement stochastic auditing by modifying
 audit probabilities in the way shown above.
 To analyze a model 
\begin_inset Formula $m$
\end_inset

 with audit probability of say 20%, simply enter the following line 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

m = set.audit.prob(m,0.2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
after you have initialized the model, but before you solve it.
 Here is an example that compares the effects of auditing in Green-Porter
 Style models:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# Initialize models
\end_layout

\begin_layout Plain Layout

m.pm = init.payoffs.green.porter()
\end_layout

\begin_layout Plain Layout

m.imp = init.signals.green.porter(m.pm)
\end_layout

\begin_layout Plain Layout

m.10 = set.audit.prob(m.imp,0.1)
\end_layout

\begin_layout Plain Layout

m.imp$name = "Green-Porter (no audits)"
\end_layout

\begin_layout Plain Layout

m.pm$name = "Green-Porter (permanent audits)"
\end_layout

\begin_layout Plain Layout

m.10$name = "Green-Porter (10% audits)"
\end_layout

\begin_layout Plain Layout

# Solve models using symmetric action profiles on the
\end_layout

\begin_layout Plain Layout

# equilibrium path
\end_layout

\begin_layout Plain Layout

ai.mat = get.ai.mat(m)
\end_layout

\begin_layout Plain Layout

ignore.ae = !(ai.mat[,1]==ai.mat[,2] |
\end_layout

\begin_layout Plain Layout

ai.mat[,1] == (ai.mat[,2]-1))
\end_layout

\begin_layout Plain Layout

m.10 = solve.game(m.10 ,ignore.ae=ignore.ae)
\end_layout

\begin_layout Plain Layout

m.pm = solve.game(m.pm ,ignore.ae=ignore.ae)
\end_layout

\begin_layout Plain Layout

m.imp = solve.game(m.imp,ignore.ae=ignore.ae)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Compare the models graphically
\end_layout

\begin_layout Plain Layout

plot.compare.models(m.10,m.imp,xvar="delta",yvar="Ue",
\end_layout

\begin_layout Plain Layout

m1.name = "10% audit", m2.name = "no audits",
\end_layout

\begin_layout Plain Layout

legend.pos ="bottomright")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

plot.compare.models(m.10,m.pm,xvar="delta",yvar="Ue",
\end_layout

\begin_layout Plain Layout

m1.name = "10% audit", m2.name = "100% audits",
\end_layout

\begin_layout Plain Layout

legend.pos ="bottomright")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The resulting graphs are shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Collusion_audits"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename audit_10vsNO.eps
	scale 50

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename audit_10vs100.eps
	scale 50

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Collusion with different auditing probabilities
\begin_inset CommandInset label
LatexCommand label
name "fig:Collusion_audits"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
We find that an audit in 10% of periods can already substantially increase
 the scope for collusion.
 Thus having a perfect, incorruptible auditor can be very valuable.
 The following exercise invites you to study more of the effects of auditing:
\end_layout

\begin_layout Exercise
Pick one game with imperfect public monitoring, e.g.
 the Noisy Prisoners' Dilemma game or some Green-Porter model.
 Also pick a finite grid of auditing probabilities and perform graphical
 comparative statics of maximum equilibrium payoffs with respect to the
 auditing probability 
\begin_inset Formula $\pi$
\end_inset

 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Analysing-comparative-statics"

\end_inset

 for how to perform such comparative statics).
 Assume that auditing all firms in one period involves costs of 
\begin_inset Formula $M>0$
\end_inset

, so that expected equilibrium payoffs that account for auditing costs are
 
\begin_inset Formula $U-\pi M$
\end_inset

.
 Find the optimal auditing probability (from your grid) for every discount
 factor.
\end_layout

\begin_layout Standard
What I explained above, is just a very simple framework.
 I am working on a more extended set-up that allows to condition audit probabili
ties on the realized signals and explicitly gives players the opportunity
 to refuse to be audited or refuse to pay any auditing costs.
 
\begin_inset Note Note
status collapsed

\begin_layout Section
Secret manipulation of signals
\end_layout

\begin_layout Plain Layout
This Section gives a short outlook on another topic I am currently working
 on.
 
\end_layout

\begin_layout Plain Layout
Optimal equilibria in repeated games typically strongly exploit the fact
 that the signal distribution is commonly and exactly known by all players
 and cannot be manipulated.
 Consider for example the noisy prisoners' dilemma game from Section 7.
 If 
\begin_inset Formula $\beta$
\end_inset

 is low and the discount factor 
\begin_inset Formula $\delta$
\end_inset

 is large, optimal equilibria require very large transfers from player 1
 to player 2 after signal 
\begin_inset Formula $y_{1}$
\end_inset

 and similarly large transfers in the other direction after signal 
\begin_inset Formula $y_{2}$
\end_inset

.
 In other words, optimal equilibria require large differences in player
 1 and 2's continuation payoffs when either signals 
\begin_inset Formula $y_{1}$
\end_inset

 or 
\begin_inset Formula $y_{2}$
\end_inset

 are realized.
 The bang-bang result by Abreu, Pearce and Stacchetti (1990), suggests that
 these large differences in continuation payoffs are not an artifact of
 our assumption that monetary transfers are possible, but rather constitute
 a general aspect of optimal equilibria in games with imperfect public monitorin
g.
\end_layout

\begin_layout Plain Layout
Given the assumptions of the model, such strongly asymmetric continuation
 payoffs are no problem, e.g.
 in the prisoners' dilemma game signals 
\begin_inset Formula $y_{1}$
\end_inset

 and 
\begin_inset Formula $y_{2}$
\end_inset

 are equally likely on the equilibrium path in expectation these transfers
 exactly cancel out.
 Intuitively, one might feel that such equilibria are not very robust, however.
 In particular, large differences in continuation payoffs may give players
 strong incentives to manipulate the signal distribution in some way.
 Below, I present a simple framework that allows to study optimal equilibria
 given that players can manipulate signals.
\end_layout

\begin_layout Plain Layout
Consider an original repeated two player game with action space 
\begin_inset Formula $A$
\end_inset

, signal space 
\begin_inset Formula $Y$
\end_inset

, expected stage game payoffs 
\begin_inset Formula $g(a)$
\end_inset

 and signal distribution 
\begin_inset Formula $\phi(y|a)$
\end_inset

.
 We can convert it into a game with the possibility of costly signal manipulatio
n.
 An extended action of player 
\begin_inset Formula $i$
\end_inset

 is described by 
\begin_inset Formula $\tilde{a}_{i}=(a_{i},s_{i},x_{i})$
\end_inset

 with 
\begin_inset Formula $a_{i}\in A_{i}$
\end_inset

, 
\begin_inset Formula $x_{i}\in Y$
\end_inset

 and 
\begin_inset Formula $s_{i}\in S$
\end_inset

 where 
\begin_inset Formula $S$
\end_inset

 is a finite subset of the interval 
\begin_inset Formula $[0,\frac{1}{2}]$
\end_inset

 containing 0.
 Basically, 
\begin_inset Formula $s_{i}$
\end_inset

 shall measure the strength of effort to manipulate the signal distribution
 and for the case 
\begin_inset Formula $s_{i}>0$
\end_inset

 the variable 
\begin_inset Formula $x_{i}$
\end_inset

 denotes the desired signal towards which player 
\begin_inset Formula $i$
\end_inset

 wants the signal distribution to manipulate.
 The new signal distribution shall be given by
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{equation}
\tilde{\phi}(y|(a,x,s))=\left(1-s_{1}-s_{2}\right)\phi(y|a)+I_{\left[y=x_{1}\right]}s_{1}+I_{\left[y=x_{2}\right]}s_{2}
\end{equation}

\end_inset


\end_layout

\begin_layout Plain Layout
where 
\begin_inset Formula $I_{[...]}$
\end_inset

 is the indicator function.
 So with probability 
\begin_inset Formula $s_{i}$
\end_inset

 player 
\begin_inset Formula $i$
\end_inset

 is successful in his attempt to manipulate the signal, which then realizes
 as 
\begin_inset Formula $y=x_{i}$
\end_inset

.
 Clearly, many other ways can be formulated how a signal distribution could
 be manipulated, but the method above is simple and can be used for all
 2 player stage games (for 
\begin_inset Formula $n$
\end_inset

 player games, one could restrict 
\begin_inset Formula $s_{i}$
\end_inset

 not to exceed 
\begin_inset Formula $\frac{1}{n}$
\end_inset

 or specify some non-linear deformation of the signal distribution).
 Here, we assume that any attempt to manipulate the signal distribution
 itself cannot be detected.
 This assumption can be relaxed, however.
\end_layout

\begin_layout Plain Layout
Expected stage game payoffs shall be given by
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{equation}
\tilde{g}_{i}(a,x,s)=g_{i}(a)-k(s_{i})
\end{equation}

\end_inset


\end_layout

\begin_layout Plain Layout
where 
\begin_inset Formula $k$
\end_inset

 is some increasing cost function of manipulation effort with 
\begin_inset Formula $k(0)=0$
\end_inset

.
 Basically, I assume that manipulation of the signal distribution does not
 affect expected payoffs.
 I find this assumption convenient, since it allows to study purely the
 effect of the manipulation opportunity on the the possibility of players
 to efficiently coordinate their continuation play.
 The drawback is that it is not really compatible with the view that 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $g_{i}(a)$
\end_inset

 is simply the expected payoff function given some underlying payoff function
 
\begin_inset Formula $\hat{g}_{i}(y,a_{i})$
\end_inset

.
 My formulation would be consistent only under the assumption that payoffs
 only depend on the action profile 
\begin_inset Formula $a$
\end_inset

 and that players condition future play only on the signal 
\begin_inset Formula $y$
\end_inset

 but not on any information that is contained in their own payoff.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Basically, a player's payoff can be considered as a private signal.
 If this private signal contains information about other players actions
 that is not contained in the signal 
\begin_inset Formula $y$
\end_inset

, it will in general no longer hold that the set of pure strategy PPE payoffs
 is identical to the set of pure strategy sequential equilibrium payoffs.
\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
The toolbox contains a function 
\family typewriter
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
make.game.with.signal.manipulation
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 that can convert any game into a game with signal manipulation with a very
 simple structure 
\begin_inset Formula $S=\left\{ 0,\bar{s}\right\} $
\end_inset

, i.e.
 manipulation can only take place at some fixed level
\begin_inset Formula $\bar{s}$
\end_inset

.
 The following code compares noisy prisoners' dilemma games with and without
 the possibility of signal manipulation:
\begin_inset Foot
status open

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Of course you need to have defined the function make.noisy.pd.game (see Section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Noisy PD Game"

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# Parameters of the Noisy PD Game
\end_layout

\begin_layout Plain Layout

d=1.2;s=3;lambda=0.1;mu=0.2;alpha=0.1;beta=0.2;psi = 1
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

# Parameters for signal manipulation
\end_layout

\begin_layout Plain Layout

pi.man = 0.5; cost = 1
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

# m: model without signal manipulation
\end_layout

\begin_layout Plain Layout

m = init.noisy.pd.game(d,s,lambda,mu,alpha,beta,psi)
\end_layout

\begin_layout Plain Layout

m = solve.game(m)
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

# m.manip: model with signal manipulation 	
\end_layout

\begin_layout Plain Layout

m.manip = make.game.with.signal.manipulation(m,
\end_layout

\begin_layout Plain Layout

                        pi.man=pi.man,cost=cost)
\end_layout

\begin_layout Plain Layout

m.manip = solve.game(m.manip)
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

# Plot comparison of both models
\end_layout

\begin_layout Plain Layout

plot.compare.models(m,m.manip,xvar="L",yvar="Ue",
\end_layout

\begin_layout Plain Layout

      m1.name="m",m2.name="m.manip",
\end_layout

\begin_layout Plain Layout

      legend.pos = "topleft",identify="Ue")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
While the model is solved, the output of the linear programming solver usually
 consists of a lot of encouraging lines with text: PROBLEM HAS NO FEASIBLE
 SOLUTION.
 That is due to the fact that some combinations of preferred action profile
 and signal manipulation scheme cannot be implemented for any discount factor.
 The resulting plot under the specified parameters is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:manip_vs_no_manip"

\end_inset

.
 (The plot is interactive, clicking on some point shows in the RGui the
 corresponding optimal action profiles of each model at the selected liquidity
 level.)
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename manip_noisypd.eps
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Payoff Comparison Noisy PD games with and without signal manipulation
\begin_inset CommandInset label
LatexCommand label
name "fig:manip_vs_no_manip"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Under the actual parameter constellations, we find that it is never optimal
 that players manipulate the signal on the equilibrium path and we find
 the same critical discount factor to implement mutual cooperation in the
 games with and without the possibility of signal manipulation.
 
\end_layout

\begin_layout Plain Layout
However, much more money burning is needed to implement mutual cooperation
 under the possibility of signal manipulation and money burning remains
 necessary as 
\begin_inset Formula $\delta\rightarrow1$
\end_inset

, i.e.
 no folk theorem holds.
 That is due to the fact that the cost of signal manipulation define an
 maximal bound on the differences between the two players continuation payoffs
 after some signals.
 In other words, there is a limit on the scope of efficient asymmetric punishmen
ts after signals 
\begin_inset Formula $y_{1}$
\end_inset

 and 
\begin_inset Formula $y_{2}$
\end_inset

 and optimal equilibria have to rely more on inefficient symmetric punishments
 that require money burning.
 (Money burning can equivalently interpreted as a positive probability of
 moving to a state where mutual defection (D,D) is played in the future
 period, see Section 
\end_layout

\begin_layout Plain Layout
In some sense, one could therefore say that the possibility of signal manipulati
on can provide some justification for papers that restrict attention to
 inefficient symmetric punishment schemes instead of modeling efficient
 asymmetric punishments.
 If one would account for the possibility of signal manipulation there can
 be a shift towards more inefficient punishment schemes.
 The implications of explicitly modeling the possibility of manipulating
 signals are much richer, however.
 If you play around with different parameter constellations, you will find,
 for example, that sometimes optimal equilibria allow players to manipulate
 signals.
\end_layout

\end_inset


\end_layout

\begin_layout Part
Appendices
\end_layout

\begin_layout Section
Some Hints for Debugging
\end_layout

\begin_layout Standard
When I want to study a new class of games, it only seldom happens that the
 code runs on the first try without any errors.
 At least when I constructed some new example there always was some mistake
 in the beginning.
 Furthermore, the toolbox itself is in a very early stage and may still
 contain errors.
 Also the toolbox is not very user friendly when you initialize a game with
 some incompatible parameter constellation.
 Most likely, you will get some quite incomprehensible error message.
\end_layout

\begin_layout Standard
In this Appendix, I want to illustrate, how to find and correct an error.
 Consider the following flawed version of the function from Section 4.3 that
 shall initialize and solve an n-player public goods game:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

pg.game = function(n,X,k=rep(((1+1/n)/2),n)) {
\end_layout

\begin_layout Plain Layout

  store.objects("pg.game") 
\end_layout

\begin_layout Plain Layout

  #restore.objects("pg.game")  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  g.fun = function(x.mat) {
\end_layout

\begin_layout Plain Layout

    store.objects("g.fun")
\end_layout

\begin_layout Plain Layout

    #restore.objects("g.fun")
\end_layout

\begin_layout Plain Layout

    g = matrix(0,NROW(x.mat),n)
\end_layout

\begin_layout Plain Layout

    xsum = rowSums(x.mat)
\end_layout

\begin_layout Plain Layout

    for (i in 1:n) {
\end_layout

\begin_layout Plain Layout

      g[,i] = xsum / n - k[i]*x.mat[,i]
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    g
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  name=paste(n,"Player Public Goods Game")
\end_layout

\begin_layout Plain Layout

  m = init.game(n=2,g.fun=g.fun,action.val = X,
\end_layout

\begin_layout Plain Layout

	             name=name, lab.ai=round(X,2))
\end_layout

\begin_layout Plain Layout

  m=solve.game(m)
\end_layout

\begin_layout Plain Layout

  plot(m)
\end_layout

\begin_layout Plain Layout

  m
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When I call the function, I get an error:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none">>=
\end_layout

\begin_layout Plain Layout

m = pg.game(n=3,X=0:10,k=c(0.4,0.6,0.8))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The error message is probably not very informative for you.
 To get more insights, were the error occurred, we can make the following
 function call:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none">>=
\end_layout

\begin_layout Plain Layout

traceback()
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\color blue
## 3: g.fun(val.mat)
\end_layout

\begin_layout Standard

\family typewriter
\color blue
## 2: init.game(n = 2, g.fun = g.fun, action.val = X, name = name, 
\end_layout

\begin_layout Standard

\family typewriter
\color blue
##     lab.ai = round(X, 2))
\end_layout

\begin_layout Standard

\family typewriter
\color blue
## 1: pg.game(n = 3, X = 0:10, k = c(0.4, 0.6, 0.8))
\end_layout

\begin_layout Standard
At the top of the resulting list, you see the function where the error has
 occurred, below you find the remaining call stack, i.e.
 the functions from which that function has been called.
 (Probably, you already saw the error, but please pretend not to, so that
 I can explain how a blind me would proceed debugging.)
\end_layout

\begin_layout Standard
From the traceback, we know that the error occurred somewhere in the function
 
\family typewriter
g.fun
\family default
, but where exactly? R offers several methods for debugging that allow to
 execute the commands in a function step by step.
 These debugging facilities are explained, e.g.
 in 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://cran.r-project.org/doc/manuals/R-exts.pdf
\end_layout

\end_inset

 (Section 4) or in 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://cran.r-project.org/doc/Rnews/Rnews_2003-3.pdf
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Personally, I prefer a slightly different approach that I already briefly
 discussed in the hints on R programming in Section 4.
 At the beginning of almost all functions that I create, I add the lines
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none">>=
\end_layout

\begin_layout Plain Layout

store.objects("function.name")
\end_layout

\begin_layout Plain Layout

#restore.objects("function.name")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first line stores all the local variables of the function in a global
 variable container.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
All variables means all local variables that are known when 
\family typewriter
store.objects
\family default
 is called.
 If, as I usually do, 
\family typewriter
store.objects 
\family default
is called at the beginning of a function only the arguments of the function
 call are stored.
\end_layout

\end_inset

 The second line is commented, i.e.
 it will not be run.
 However, if you want to debug the function, you can paste that line and
 all stored parameters from the last time the function was called, will
 be copied in the global environment.
 You can then simple paste the remaining code of the function and see where
 the error occurred.
 Let us apply this procedure with 
\family typewriter
g.fun:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none">>=
\end_layout

\begin_layout Plain Layout

restore.objects("g.fun"); restore.objects("pg.game")
\end_layout

\begin_layout Plain Layout

g = matrix(0,NROW(x.mat),n)
\end_layout

\begin_layout Plain Layout

  xsum = rowSums(x.mat)
\end_layout

\begin_layout Plain Layout

  for (i in 1:n) {
\end_layout

\begin_layout Plain Layout

    g[,i] = xsum / n - k[i]*x.mat[,i]
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ah...
 we get an error in the for loop.
 Practically, the integer 
\family typewriter
\color black
i
\family default
\color inherit
 will keep the value it had when the error was thrown...
 This means we can simple paste the interior of the for loop (or parts of
 the commands) to investigate further where the error has occured.
 Let us thus proceed the investigation by typing the following sequence
 of commands:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none">>=
\end_layout

\begin_layout Plain Layout

i
\end_layout

\begin_layout Plain Layout

g[,i] = xsum / n - k[i]*x.mat[,i]
\end_layout

\begin_layout Plain Layout

n
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\color blue
\begin_inset Note Note
status collapsed

\begin_layout LyX-Code
g[,i] = xsum / n - k[i]*x.mat[,i]
\end_layout

\begin_layout LyX-Code

\color blue
Error: subscript out of bounds
\end_layout

\begin_layout LyX-Code
n
\end_layout

\begin_layout LyX-Code

\color blue
100
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What does that mean? 
\family typewriter
\color black
n=100
\family default
\color inherit
 ??? That does not make any sense at all...
 OK, the reason for this apparently strange result is connected to the Advanced
 Programming Hints, I gave in Section 4.3 and illustrates one weakness in
 my approach to debugging.
 The function 
\family typewriter
\color black
g.fun
\family default
\color inherit
 uses the variable 
\family typewriter
n
\family default
 from its parent function 
\family typewriter
\color black
pg.game
\family default
\color inherit
.
 As 
\family typewriter
n
\family default
 was not an argument of 
\family typewriter
g.fun
\color black
,
\family default
\color inherit
 the function call 
\family typewriter
store.objects(
\color black
"g.fun")
\family default
\color inherit
 did not store the variable 
\family typewriter
\color black
n
\family default
\color inherit
, i.e.
 the variable 
\family typewriter
\color black
n
\family default
\color inherit
 was not restored properly by 
\family typewriter
\color black
restore.objects("g.fun")
\family default
\color inherit
 and it just kept the value it had from some previous assignment.
 To solve the problem, we also have to call 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none">>=
\end_layout

\begin_layout Plain Layout

restore.objects("pg.game")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
in order to restore the local variables of the last call to 
\family typewriter
\color black
pg.game
\family default
\color inherit
 (this assumes that 
\family typewriter
pg.game
\family default
 has not changed the parameter n in its function body, which is the case).
\end_layout

\begin_layout Standard
Having done this, let us paste again the inner code of the function and
 then continue the search for the reason of the error:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none">>=
\end_layout

\begin_layout Plain Layout

n
\end_layout

\begin_layout Plain Layout

g[,i]
\end_layout

\begin_layout Plain Layout

k[i]
\end_layout

\begin_layout Plain Layout

x.mat[,i]
\end_layout

\begin_layout Plain Layout

dim(x.mat)
\end_layout

\begin_layout Plain Layout

i
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout LyX-Code
n
\end_layout

\begin_layout LyX-Code

\color blue
3
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
g[,i]
\end_layout

\begin_layout LyX-Code
  [
\color blue
1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0 0 0 0
\end_layout

\begin_layout LyX-Code

\color blue
 [49] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
\end_layout

\begin_layout LyX-Code

\color blue
 [97] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
k[i]
\end_layout

\begin_layout LyX-Code

\color blue
[1] 0.8
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
x.mat[,i]
\end_layout

\begin_layout LyX-Code

\color blue
Error: subscript out of bounds
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
dim(x.mat)
\end_layout

\begin_layout LyX-Code

\color blue
[1] 121   2
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
i
\end_layout

\begin_layout LyX-Code

\color blue
3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aah, the culprit is the matrix of action values argument 
\family typewriter
x.mat
\family default
! The matrix of action values has only two columns, even though I have told
 the function 
\family typewriter
\color black
pg.game
\family default
\color inherit
 that it shall set 
\family typewriter
\color black
n=3
\family default
\color inherit
, i.e.
 it shall initialize a three player game.
 So let us investigate the function that calls 
\family typewriter
g.fun
\family default
.
 Recall the traceback:
\end_layout

\begin_layout LyX-Code

\color blue
3: g.fun(val.mat)
\end_layout

\begin_layout LyX-Code

\color blue
2: init.game(n = 2, g.fun = g.fun, action.val = X, name = name, 
\end_layout

\begin_layout LyX-Code

\color blue
       lab.ai = round(X, 2))
\end_layout

\begin_layout LyX-Code

\color blue
1: pg.game(n = 3, X = 0:10, k = c(0.4, 0.6, 0.8))
\end_layout

\begin_layout Standard
This means it was 
\family typewriter
\color black
init.game 
\family default
\color inherit
that called 
\family typewriter
g.fun
\family default
.

\color blue
 
\color inherit
But 
\family typewriter
init.game
\family default
 is a function of the toolbox, not a user defined function.
 This is no problem, as there are different ways how you can access the
 source code of a function of my toolbox.
 One way is to simply type the function name (without any brackets or arguments)
 in the R prompt:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none">>=
\end_layout

\begin_layout Plain Layout

init.game
\end_layout

\begin_layout Plain Layout

# Output ommitted in the PDF file
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The whole code of function will then be displayed in your console.
 You can simply copy and paste it into your text editor and from there past
 the desired pieces into your code.
 The drawback is that in the version you see, all comments have been removed
 (inclusive the commented line 
\family typewriter
\color black
#restore.objects(
\color inherit
"init.game"
\color black
) )
\family default
\color inherit
An alternative way is to find the function directly from the source files
 of the toolbox that you can find on my homepage.
 These source files still contain all comments.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
My source code is distributed across different .r files.
 If you use the Crimson Editor, the feature 
\begin_inset Quotes eld
\end_inset

Find in files...
\begin_inset Quotes erd
\end_inset

 in the menu 
\begin_inset Quotes eld
\end_inset

Search
\begin_inset Quotes erd
\end_inset

 is helpful to find in which file a certain function is defined.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Most of my own functions start with a call to 
\family typewriter
store.objects
\family default
, i.e.
 you can debug them in the way described above.
 Let us do so, i.e.
 we paste the code from 
\family typewriter
\color black
restore.objects
\family default
\color inherit
 up to the call to 
\family typewriter
\color black
g.fun
\family default
\color inherit
:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=FALSE, fig.keep="none">>=
\end_layout

\begin_layout Plain Layout

restore.objects("init.game")
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		repgames.startup()
\end_layout

\begin_layout Plain Layout

		  
\end_layout

\begin_layout Plain Layout

		m = list()	  
\end_layout

\begin_layout Plain Layout

	  class(m)=c("repgame","list")
\end_layout

\begin_layout Plain Layout

	  m$name = name
\end_layout

\begin_layout Plain Layout

	  if (is.null(sol.type)) {
\end_layout

\begin_layout Plain Layout

  	  if (is.null(phi.mat)) {
\end_layout

\begin_layout Plain Layout

    	  sol.type="pm"
\end_layout

\begin_layout Plain Layout

  	  } else {
\end_layout

\begin_layout Plain Layout

    	  sol.type = "imp"
\end_layout

\begin_layout Plain Layout

  	  }
\end_layout

\begin_layout Plain Layout

	  }
\end_layout

\begin_layout Plain Layout

	  m$sol.type = sol.type
\end_layout

\begin_layout Plain Layout

	  m$n = n
\end_layout

\begin_layout Plain Layout

	  
\end_layout

\begin_layout Plain Layout

  	                     		
\end_layout

\begin_layout Plain Layout

	  action.val.list = NULL
\end_layout

\begin_layout Plain Layout

		if (!is.null(g) & !is.null(ai.dim)) {
\end_layout

\begin_layout Plain Layout

			gtype="g.mat"
\end_layout

\begin_layout Plain Layout

		} else if (!is.null(g.fun) & !is.null(action.val)) {                 	   
                          
\end_layout

\begin_layout Plain Layout

			gtype="g.fun"
\end_layout

\begin_layout Plain Layout

			if (!is.list(action.val)) {
\end_layout

\begin_layout Plain Layout

				action.val.list = replicate(m$n,action.val, simplify=FALSE)
\end_layout

\begin_layout Plain Layout

			} else {
\end_layout

\begin_layout Plain Layout

				action.val.list = action.val
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		} else if (!is.null(g1)) {
\end_layout

\begin_layout Plain Layout

			gtype="g1"
\end_layout

\begin_layout Plain Layout

			if (is.null(g2)) {
\end_layout

\begin_layout Plain Layout

				g2 = t(g1)
\end_layout

\begin_layout Plain Layout

				symmetric=TRUE
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		} else {
\end_layout

\begin_layout Plain Layout

			stop("init.game: You have to specify either g and ai.dim or g.fun and action.val
 or g1.")
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

	                             
\end_layout

\begin_layout Plain Layout

	  m$symmetric = symmetric
\end_layout

\begin_layout Plain Layout

		m$audit.prob = audit.prob
\end_layout

\begin_layout Plain Layout

	  
\end_layout

\begin_layout Plain Layout

	  # Initialize ai.dim
\end_layout

\begin_layout Plain Layout

	  if (gtype=="g.mat")  {
\end_layout

\begin_layout Plain Layout

		  if (NROW(ai.dim)==1) {
\end_layout

\begin_layout Plain Layout

				m$ai.dim = rep(ai.dim,m$n)
\end_layout

\begin_layout Plain Layout

			} else {
\end_layout

\begin_layout Plain Layout

				m$ai.dim = ai.dim
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		} else if (gtype=="g.fun") {
\end_layout

\begin_layout Plain Layout

			if (is.list(action.val)) {
\end_layout

\begin_layout Plain Layout

				m$a.dim = sapply(action.val,NROW)
\end_layout

\begin_layout Plain Layout

			} else {
\end_layout

\begin_layout Plain Layout

				m$a.dim = rep(NROW(action.val),m$n)
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		} else if (gtype=="g1") {
\end_layout

\begin_layout Plain Layout

			m$a.dim = c(NROW(g1),NCOL(g1))
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		m$shift.ai = rev(cumprod(rev(m$a.dim))) / m$a.dim[1:n]
\end_layout

\begin_layout Plain Layout

		m$modulus.ai = c(prod(m$a.dim),m$shift.ai[-n])
\end_layout

\begin_layout Plain Layout

		# Number of action profiles
\end_layout

\begin_layout Plain Layout

		m$nA = prod(m$a.dim)
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		# Initialize labels of the different actions
\end_layout

\begin_layout Plain Layout

		if (!is.null(lab.ai)) {
\end_layout

\begin_layout Plain Layout

			if (is.list(lab.ai)) {
\end_layout

\begin_layout Plain Layout

				m$lab.ai = lab.ai
\end_layout

\begin_layout Plain Layout

				if (length(lab.ai)==1)
\end_layout

\begin_layout Plain Layout

					for (i in 2:m$n) m$lab.ai[[i]] = m$lab.ai[[1]];
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

			} else {
\end_layout

\begin_layout Plain Layout

				m$lab.ai = replicate(m$n,lab.ai,simplify=FALSE)
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			if (NROW(m$lab.ai[[1]]) != m$a.dim[1]) {
\end_layout

\begin_layout Plain Layout

				stop("Error: the parameter lab.ai has the wrong dimensions.")
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			if (gtype=="g1") {
\end_layout

\begin_layout Plain Layout

				rownames(g1)=rownames(g2)=m$lab.ai[[1]]
\end_layout

\begin_layout Plain Layout

				colnames(g1)=colnames(g2)=m$lab.ai[[2]]			
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		} else {
\end_layout

\begin_layout Plain Layout

			m$lab.ai = list()
\end_layout

\begin_layout Plain Layout

		  if (gtype=="g.mat")  {
\end_layout

\begin_layout Plain Layout

			  # If gtype=="g.mat" then lab.ai must be supplied
\end_layout

\begin_layout Plain Layout

			} else if (gtype=="g.fun") {
\end_layout

\begin_layout Plain Layout

				if (!is.null(names(action.val.list[[1]]))) {
\end_layout

\begin_layout Plain Layout

					for (i in 1:n) m$lab.ai[[i]] = names(action.val.list[[i]]);
\end_layout

\begin_layout Plain Layout

				} else {
\end_layout

\begin_layout Plain Layout

					m$lab.ai = action.val.list
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			} else if (gtype=="g1") {
\end_layout

\begin_layout Plain Layout

				m$lab.ai[[1]] = rownames(g1)
\end_layout

\begin_layout Plain Layout

				m$lab.ai[[2]] = colnames(g1)
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		# Initialize labels of the different action profiles
\end_layout

\begin_layout Plain Layout

		if (add.labels) { 
\end_layout

\begin_layout Plain Layout

			if (is.null(lab.a)) {
\end_layout

\begin_layout Plain Layout

				if (n==2) {
\end_layout

\begin_layout Plain Layout

					# Default format.
 In a prisoners' dilemma game looks e.g.
 "C|D"
\end_layout

\begin_layout Plain Layout

	  			m$lab.a = as.vector(t(outer(m$lab.ai[[1]],m$lab.ai[[2]],function(x,y){paste(x,
y,sep="|")})))
\end_layout

\begin_layout Plain Layout

  			} else {
\end_layout

\begin_layout Plain Layout

	  			lab.a.work = make.grid.matrix(x=m$lab.ai)
\end_layout

\begin_layout Plain Layout

	  			m$lab.a = paste(lab.a.work[,1],lab.a.work[,2],sep="|")
\end_layout

\begin_layout Plain Layout

	  			for (i in 3:m$n)
\end_layout

\begin_layout Plain Layout

	  				m$lab.a = paste(m$lab.a,lab.a.work[,i],sep="|")
\end_layout

\begin_layout Plain Layout

  			}
\end_layout

\begin_layout Plain Layout

			} else {
\end_layout

\begin_layout Plain Layout

				m$lab.a = lab.a
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			# m$ind.a can be used to find the index of an action profile if its name
 is known
\end_layout

\begin_layout Plain Layout

			m$ind.a = 1:m$nA
\end_layout

\begin_layout Plain Layout

			names(m$ind.a) = m$lab.a
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		# A vector that specifies whether a certain action profile is symmetric
 or not		
\end_layout

\begin_layout Plain Layout

		m$sym.a = rep(FALSE,m$nA)
\end_layout

\begin_layout Plain Layout

		if (n ==2) {
\end_layout

\begin_layout Plain Layout

			if(m$a.dim[1] == m$a.dim[2]) {
\end_layout

\begin_layout Plain Layout

				m$sym.a[((1:m$a.dim[1])-1)*m$a.dim[1]+(1:m$a.dim[1])]=TRUE
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if (is.null(action.val.list)) 
\end_layout

\begin_layout Plain Layout

  	  action.val.list = lapply(m$a.dim, function(x) 1:x)
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

  	m$action.val.mat = make.grid.matrix(x=action.val.list)
\end_layout

\begin_layout Plain Layout

  	
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

# Initialize ai.dim
\end_layout

\begin_layout Plain Layout

if (gtype=="g.mat")  {
\end_layout

\begin_layout Plain Layout

  m$g = g
\end_layout

\begin_layout Plain Layout

} else if (gtype=="g.fun") {
\end_layout

\begin_layout Plain Layout

  val.mat = make.grid.matrix(x=action.val.list)
\end_layout

\begin_layout Plain Layout

  m$g = g.fun(val.mat)
\end_layout

\begin_layout Plain Layout

} else if (gtype=="g1") {
\end_layout

\begin_layout Plain Layout

  m$g1 = g1
\end_layout

\begin_layout Plain Layout

  m$g2 = g2
\end_layout

\begin_layout Plain Layout

  # Table that contains all payoffs nA rows and n columns
\end_layout

\begin_layout Plain Layout

  m$g = cbind(as.vector(t(g1)),as.vector(t(g2)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

restore.objects("init.game")
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

m = list()	  
\end_layout

\begin_layout Plain Layout

class(m)=c("repgame","list")
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

#[...
 a lot of more code, omitted here...]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# Initialize ai.dim
\end_layout

\begin_layout Plain Layout

if (gtype=="g.mat")  {
\end_layout

\begin_layout Plain Layout

  m$g = g
\end_layout

\begin_layout Plain Layout

} else if (gtype=="g.fun") {
\end_layout

\begin_layout Plain Layout

  val.mat = make.grid.matrix(x=action.val.list)
\end_layout

\begin_layout Plain Layout

  m$g = g.fun(val.mat)
\end_layout

\begin_layout Plain Layout

} else if (gtype=="g1") {
\end_layout

\begin_layout Plain Layout

  m$g1 = g1
\end_layout

\begin_layout Plain Layout

  m$g2 = g2
\end_layout

\begin_layout Plain Layout

  # Table that contains all payoffs nA rows and n columns
\end_layout

\begin_layout Plain Layout

  m$g = cbind(as.vector(t(g1)),as.vector(t(g2)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The error took place in this if structure....
 Let us dissect it further:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

gtype
\end_layout

\begin_layout Plain Layout

val.mat = make.grid.matrix(x=action.val.list)
\end_layout

\begin_layout Plain Layout

m$g = g.fun(val.mat)
\end_layout

\begin_layout Plain Layout

val.mat[1:3,]
\end_layout

\begin_layout Plain Layout

action.val.list
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout LyX-Code
gtype
\end_layout

\begin_layout LyX-Code

\color blue
[1] "g.fun"
\end_layout

\begin_layout LyX-Code
val.mat = make.grid.matrix(x=action.val.list)
\end_layout

\begin_layout LyX-Code
m$g = g.fun(val.mat)
\end_layout

\begin_layout LyX-Code

\color blue
Error: subscript out of bounds
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
val.mat[1:3,]
\end_layout

\begin_layout LyX-Code

\color blue
     [,1] [,2]
\end_layout

\begin_layout LyX-Code

\color blue
[1,]    0    0
\end_layout

\begin_layout LyX-Code

\color blue
[2,]    0    1
\end_layout

\begin_layout LyX-Code

\color blue
[3,]    0    2
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
 action.val.list
\end_layout

\begin_layout LyX-Code

\color blue
[[1]]
\end_layout

\begin_layout LyX-Code

\color blue
 [1]  0  1  2  3  4  5  6  7  8  9 10
\end_layout

\begin_layout LyX-Code

\color blue
[[2]]
\end_layout

\begin_layout LyX-Code

\color blue
 [1]  0  1  2  3  4  5  6  7  8  9 10
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OK...
 the matrix 
\family typewriter
\color black
val.mat
\family default
\color inherit
 has only 2 columns, and the list 
\family typewriter
\color black
action.val.list
\family default
\color inherit
 only 2 vector elements.
 But I did initialize a three player game, or didn't I.
 Let's check...
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

n
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the function 
\family typewriter
\color black
init.game
\family default
\color inherit
 the number of players 
\family typewriter
\color black
n
\family default
\color inherit
 is set to 2.
 Why is that...
 Let us look where we call 
\family typewriter
\color black
init.game
\family default
\color inherit
 in 
\family typewriter
\color black
pg.game.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=TRUE, echo=TRUE, fig.keep="none",tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

m = init.game(n=2,g.fun=g.fun,action.val = X,
\end_layout

\begin_layout Plain Layout

	             name=name, lab.ai=round(X,2))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, the mistake is detected! We wrongly set 
\family typewriter
\color black
n=2
\family default
\color inherit
 when calling 
\family typewriter
\color black
init.game
\family default
\color inherit
.
 Such mistakes can easily happen if one builds code by copy-and-pasting
 it from different examples.
 Correcting the bug is quickly done, by changing the line in 
\family typewriter
\color black
pg.game
\family default
\color inherit
 to
\family typewriter
\color black
:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE, eval=FALSE, echo=TRUE, fig.keep="none", tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

m = init.game(n=n,g.fun=g.fun,action.val = X,
\end_layout

\begin_layout Plain Layout

	             name=name, lab.ai=round(X,2))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now everything should work fine.
\end_layout

\begin_layout Standard
It looks like of a lot of effort to find a small typo, but that is just
 the way it often is.
 Personally, I think that with a bit of experience debugging can be quite
 fun: it is a bit like an interactive detective story between you and the
 computer.
 Furthermore, bugs are a good commitment device that force you to understand
 in detail how some piece of code works.
 The word 
\begin_inset Quotes eld
\end_inset

Interactively
\begin_inset Quotes erd
\end_inset

 in the title of this paper can well be referred to the interactive process
 of debugging the code that specifies your repeated game.
 It is a bit as if you had somebody that reads a proof of your paper and
 gives you a cryptic error message if something is wrong and step by step
 you have to encrypt what went wrong (who knows, maybe programming the computer
 implementation of your game may indeed help you to find a mistake in some
 proof).
\end_layout

\begin_layout Standard
Unfortunately, not every mistake reveals itself through an error message.
 So you also have to check whether the results of the solved model look
 sensible.
 Ideally, you know the solution for some special case and can first test
 the program on that case.
 I would definitely recommend to extensively check whether the functions
 that describe stage game payoffs and cheating payoffs work correctly.
 Remember the tools to check cheating payoffs described in Section 6.2.
 Also note that plotting is often a very powerful tool for debugging.
 
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Modifying the source code of the toolbox
\end_layout

\begin_layout Plain Layout
As the toolbox is very young, it is very likely that it still contains several
 bugs.
 Above I briefly discussed, how you can trace through the source code of
 my package.
 If you find an error in my toolbox, please send me an email (skranz@uni-bonn.de).
 I will try to correct the error, but I cannot guarantee that I will be
 able to do it quickly.
\end_layout

\begin_layout Plain Layout
So maybe you prefer to correct the error yourself.
 To do this, you have to download the source code from my homepage and change
 it appropriately.
 Building an R package from the changed source code is quite an endeavor,
 however.
 I rather suggest the following method (described for windows): Create a
 link of the R program that uses as working folder the folder that contains
 the source code.
 Then open R via this link.
 Instead of calling 
\family typewriter
library(repgames)
\family default
, paste the content of the file 
\family typewriter
rep_loadfiles.r
\family default
 into your console.
 This will manually load the actual version of the sources.
 Any modifications that you made to the source files will be included.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Debugging warnings
\end_layout

\begin_layout Plain Layout
Sometimes the toolbox does not throw an error that terminates the execution,
 but only a warning that sounds uncomfortable.
 Paste
\end_layout

\begin_layout LyX-Code
options(warn=2)
\end_layout

\begin_layout Plain Layout
to tell R that it shall stop after any warning, i.e.
 warnings are treated like errors.
 You can then debug in the way explained above.
 To reset to the normal mode, call
\end_layout

\begin_layout LyX-Code
options(warn=0)
\end_layout

\begin_layout Plain Layout
If you want R to stop only after some specific warning, you have to locate
 the function that throws the warning in my source code and add after the
 line that throws the warning a line 
\family typewriter
stop()
\family default
 and reload the modified source code in the way explained in the previous
 box.
\end_layout

\end_inset


\end_layout

\begin_layout Section
References
\end_layout

\begin_layout Standard
Abreu, Dilip.
 1986.
 "Extremal equilibria of oligopolistic supergames", Journal of Economic
 Theory, vol 39 (1): 191-225.
\end_layout

\begin_layout Standard
Abreu, Dilip & Pearce, David & Stacchetti, Ennio, 1986.
 "Optimal cartel equilibria with imperfect monitoring," Journal of Economic
 Theory, vol.
 39(1): 251-269.
 
\end_layout

\begin_layout Standard
Abreu, Dilip, 1988.
 "On the Theory of Infinitely Repeated Games with Discounting," Econometrica,
 56, 383-396.
\end_layout

\begin_layout Standard
Abreu, Dilip & Pearce, David & Stacchetti, Ennio, 1990.
 "Toward a Theory of Discounted Repeated Games with Imperfect Monitoring,"
 Econometrica, 58, 1041-63.
\end_layout

\begin_layout Standard
Fudenberg, Drew & Levine, David & Maskin, Eric, 1994.
 "The Folk Theorem with Imperfect Public Information," Econometrica, 62,
 997-1039.
\end_layout

\begin_layout Standard
Kranz, Sebastian & Ohlendorf, Susanne, 2009.
 
\begin_inset Quotes eld
\end_inset

Renegotiation-Proof Relational Contracts with Side Payments
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Goldluecke, Susanne & Kranz, Sebastian, 2012.
 "Infinitely Repeated Games with Imperfect Public Monitoring and Monetary
 Transfers", Journal of Economic Theory (forthcoming).
\end_layout

\begin_layout Standard
Green, Edward J & Porter, Robert H, 1984.
 "Noncooperative Collusion under Imperfect Price Information," Econometrica,
 Econometric Society, vol.
 52(1): 87-100.
 
\end_layout

\begin_layout Standard
Harrington, Joseph E.
 & Skrzypacz, Andrzej Jr., 2007.
 "Collusion under Monitoring of Sales", The RAND Journal of Economics, vol.
 38(2):314-331.
\end_layout

\begin_layout Standard
Isaac, R.M.,Walker, J.M., 1988., “Group Size Effects in Public Goods Provision:
 The Voluntary Contributions Mechanism,” Quarterly Journal of Economics
 103(1): 179-199.
\end_layout

\begin_layout Standard
Kranz, Sebastian, 2010.
 "Moral Norms in a Partly Compliant Society," Games and Economic Behavior,
 vol 68 (1): 255-274.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Part*
OLD IDEAS
\end_layout

\begin_layout Section
Models of Vertical and Horizontal Collusion
\end_layout

\begin_layout Plain Layout
Competition policy typically gets really interesting in cases where vertical
 aspects (e.g.
 between manufacturers and retailers) and horizontal aspects (between firms
 on the same level) of competition interact.
 While most literature on vertical relationships studies static two-stage
 games, there are many interesting aspects to be studied by repeated games.
 Nocke and White (2007) develop a very nice model that analyzes the effects
 of vertical integration of the ability of collusion between upstream firms.
 While the basic model restricts attention to grim-trigger strategies, they
 also study optimal equilibria with optimal penal codes.
 Finding optimal penal codes is generally not an easy task, and Nocke and
 White note that it becomes particularly complicated in their model because
 each period is modeled as sequential game, i.e.
 Abreu's optimal simple penal codes cannot be used.
\end_layout

\begin_layout Plain Layout
Basically, our theoretical paper and the toolbox only allows to study optimal
 collusion in repeated simultaneous move games.
 Does this mean that we cannot use the toolbox to study interesting models
 of horizontal and vertical collusion? No.
 In this Section, I want to illustrate that one can indeed find sensible
 simultaneous move stage game formulations to model vertical and horizontal
 collusion.
 Then using a rather small number of examples, I want to show the toolbox
 can be used to find optimal equilibria.
 I plan to extend the analysis in the future.
\end_layout

\begin_layout Subsection
One manufacturer and one retailer
\end_layout

\begin_layout Plain Layout
Let us first look at a simple case of a vertical relationship between one
 monopolistic manufacturer (firm 1) and a monopolistic retailer (firm 2).
 This example, shall mainly discuss different ways how one can specify the
 action set of set-up the stage game.
 In each period, the monopolist charges the retailer a constant price 
\begin_inset Formula $w$
\end_inset

 per good sold and the retailer sets a downstream price of 
\begin_inset Formula $p$
\end_inset


\begin_inset Formula $.$
\end_inset

 Demand of final consumers shall be described by a simple demand function
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
Q(p)=max\left\{ 100-p,0\right\} 
\]

\end_inset


\end_layout

\begin_layout Plain Layout
We assume that there are no production or retail costs, so that upstream
 and downstream profits are given by
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\pi_{1} & = & wQ(p)\\
\pi_{2} & = & (p-w)Q(p)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Plain Layout
Note that in contrast to collusion between horizontal firms, collusion between
 to vertically related monopolists can be a good thing for consumers, since
 collusion can solve the problem of double marginalization.
 
\end_layout

\begin_layout Paragraph*
Sequential move vs simultaneous move stage games
\end_layout

\begin_layout Plain Layout
Typically, such vertical interaction is modeled as a two stage game: first
 the manufacturer specifies a wholesale price 
\begin_inset Formula $w$
\end_inset

, and after observing the wholesale price, the retailer chooses its downstream
 price 
\begin_inset Formula $p$
\end_inset

.
 As our algorithm cannot characterize repeated multistage games, we have
 to model the interaction in each period as a simultaneous move game.
 In the actual context, I do not find this restriction very troublesome,
 however, for the following reasons.
 Every multi-stage game has a representation as a simultaneous move game.
 The only difference when looking at the simultaneous move game and the
 multi-stage game is that we would not impose a subgame perfection requirement
 within a period.
 This means for a discount factor 
\begin_inset Formula $\delta=0$
\end_inset

, the set of equilibria can be larger than if we would look at subgame perfect
 equilibria in the multistage game.
 However, requiring subgame perfection in the upstream-downstream relationship
 has basically only the effect to select that Nash equilibrium that is best
 for the upstream firm.
 I do not see a compelling reason why necessarily all bargaining power should
 be given to the upstream firm.
 The idea of our theoretical paper and this toolbox is to characterize the
 set of all equilibrium payoffs that can be implemented at all discount
 factor.
 Thus in the actual context, I would prefer to analyze a simultaneous move
 stage game even if the software could handle repeated multistage games.
 
\end_layout

\begin_layout Paragraph
A curse of dimensionality
\end_layout

\begin_layout Plain Layout
The critical issue is how we can find a stage game representation that is
 parsimonious enough to be analyzed with the toolbox.
 The canonical representation would be that the retailer specifies a downstream
 price 
\begin_inset Formula $p$
\end_inset

 for every possible upstream price 
\begin_inset Formula $w$
\end_inset

.
 Now assume that we want to allow upstream and downstream prices to be chosen
 from a grid of size 
\begin_inset Formula $100$
\end_inset

.
 Then there would be a total of 
\begin_inset Formula $100*100^{100}$
\end_inset

 different action profiles in the stage game....
 an awful lot.
 It is not completely clear that an algorithm that uses random sampling
 may not get decent results even in such a large action space (see Section
 5.2), but I think a smaller action space is clearly preferable.
\end_layout

\begin_layout Paragraph
The naive solution
\end_layout

\begin_layout Plain Layout
What about the naive solution that the downstream firm and upstream firm
 simply pick simultaneously a single price 
\begin_inset Formula $w$
\end_inset

 and 
\begin_inset Formula $p$
\end_inset

? Do you see already the problem? Maybe let's solve the model and let the
 computer help us to illustrate the problem.
 Paste the following code:
\end_layout

\begin_layout LyX-Code
init.vert = function(w.seq, p.seq) {
\end_layout

\begin_layout LyX-Code
  g.fun = function(wp) {
\end_layout

\begin_layout LyX-Code
    Qm = 100-wp[,2]
\end_layout

\begin_layout LyX-Code
    Qm[Qm<0]=0
\end_layout

\begin_layout LyX-Code
    g = cbind(Qm*wp[,1],Qm*(wp[,2]-wp[,1]))
\end_layout

\begin_layout LyX-Code
    return(g)
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  name=paste("Vertical (set p and w simult.)",sep="")
\end_layout

\begin_layout LyX-Code
  m = init.game(n=2,g.fun=g.fun,action.val = list(w.seq,p.seq),
\end_layout

\begin_layout LyX-Code
                name=name, lab.ai=list(w.seq,p.seq))
\end_layout

\begin_layout LyX-Code
  return(m)
\end_layout

\begin_layout LyX-Code
} 
\end_layout

\begin_layout LyX-Code
w.seq = p.seq = 1:100
\end_layout

\begin_layout LyX-Code
m = init.vert(w.seq,p.seq)
\end_layout

\begin_layout LyX-Code
m = solve.model(m)
\end_layout

\begin_layout LyX-Code
plot(m,legend.pos = "right")
\end_layout

\begin_layout Plain Layout
The resulting plot is shown in Figure ###:
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename vert_wp_sim.eps
	scale 60

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename vert_wm_sim.eps
	scale 60

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
We find that for 
\begin_inset Formula $\delta=0$
\end_inset

, both firms make 0 profits.
 The reason is simple: the sales of the upstream firm only depend on the
 final downstream price 
\begin_inset Formula $p$
\end_inset

, thus for any given 
\begin_inset Formula $p$
\end_inset

 the upstream firm has an incentive to deviate to set 
\begin_inset Formula $w=100$
\end_inset

.
 To protect itself from this exploitation the downstream firm has to guarantee
 to sell nothing by setting 
\begin_inset Formula $p=100$
\end_inset

.
 Look at m$pm.opt.mat to verify this result.
 For higher discount factors the problem can be reduced by the threat of
 punishing upstream firm if it cheats (interestingly in the selected optimal
 equilibrium action profiles for higher discount factors we find 
\begin_inset Formula $w>p$
\end_inset

.
 Note, however that we have side payments, i.e.
 the upstream firm can make fixed transfers to the downstream firm).
 Anyhow, it is clearly not a realistic assumption that the downstream can
 secretly charge a higher wholesale price and the retailer is not able to
 adapt his retail price.
\end_layout

\begin_layout Paragraph*
A simple alternative: let the retailer set markups
\end_layout

\begin_layout Plain Layout
The following exercise asks you to explore another formulation of the stage
 game.
\end_layout

\begin_layout Exercise
Assume that the retailer's action is not a downstream price 
\begin_inset Formula $p$
\end_inset

, but to choose a markup 
\begin_inset Formula $m$
\end_inset

 above the wholesale price and the resulting price is given by
\begin_inset Formula 
\[
\mbox{\ensuremath{p=w+m}}
\]

\end_inset


\end_layout

\begin_layout Exercise
Modify the model above such that firm 2 can choose a markup between 0 and
 100 instead of the downstream price and plot the resulting payoffs.
 (Be cautious of how abbreviate the variable markup, the single letter m
 is typically used to specify the variable that contains the model).
 
\end_layout

\begin_layout Exercise
If you solved the exercise correctly, you should see a plot as on the right
 hand side of Figure ###.
 The first best outcome can be achieved already for very low discount factors.
 This is not very surprising, first we have perfect monitoring, which generally
 makes it easy to implement cooperative outcomes.
 Second, note that we allow for side payments.
 With side payments it almost looks like we would allow for two part tariffs,
 and its well known that the first best outcome can be implemented with
 two part tariffs that completely solve the double marginalization problem.
 We do not completely have two part tariffs here, however, since payments
 can not be contractible linked to actions in the stage game.
 Punishment payoffs are always zero, since it is Nash equilibrium that both
 the manufacturer chooses a wholesale price of 100 and the retailer a markup
 of 100 and this Nash equilibrium implements the min-max payoffs of the
 stage game.
\end_layout

\begin_layout Paragraph*
Allowing enforceable contracts on whole sale prices
\end_layout

\begin_layout Plain Layout
The markup trick from above is in some sense a nice way to have a low dimensiona
l stage game, but it still feels a bit cheap, since the model still assumes
 that the manufacturer can secretly change the wholesale price an the surprised
 retailer then has to pay the higher wholesale price.
 In my view, the most realistic structure is that the upstream and downstream
 firm can make in every period an enforceable agreement about downstream
 prices, and if none such agreement is made then no trade takes place.
 
\end_layout

\begin_layout Plain Layout
Let us model such contracting in a stage game by the following procedure:
 both the manufacturer and retailer name simultaneously their desired wholesale
 price 
\begin_inset Formula $w^{u}$
\end_inset

 and 
\begin_inset Formula $w^{r}$
\end_inset

 respectively.
 If both players name the same wholesale price, trade takes place at this
 price and if they name a different price no trade between the two firms
 takes place.
 No explicit contracting on the retail price shall be allowed, i.e.
 we are in a legal environment where retail price maintenance is forbidden.
\end_layout

\begin_layout Plain Layout
The action space of the manufacturer remains one dimensional: he proposes
 a whole sale price 
\begin_inset Formula $w^{m}$
\end_inset

.
 The action space of the retailer becomes two dimensional, however: the
 retailer also proposes a wholesale price 
\begin_inset Formula $w^{r}$
\end_inset

 and sets a downstream price 
\begin_inset Formula $p$
\end_inset

.
 Let us call every dimension of a players action space an 
\emph on
activity
\emph default
 and say that all activities of an player form an action.
 This means we have a stage game with 3 activities 
\begin_inset Formula $w^{u}$
\end_inset


\begin_inset Formula $,w^{d}$
\end_inset

 and 
\begin_inset Formula $p$
\end_inset

 and two actions: 
\begin_inset Formula $w^{u}$
\end_inset

 and 
\begin_inset Formula $(w^{d},p$
\end_inset


\begin_inset Formula $)$
\end_inset

.
 However, I will often use the terms action profile and activity profile
 interchangeably.
 
\end_layout

\begin_layout Plain Layout
Stage game payoffs shall be given as follows:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\pi_{1}(w^{u},w^{d},p)=\begin{cases}
w^{u}Q(p) & \mbox{if \ensuremath{w^{u}=w^{d}}}\\
0 & \mbox{otherwise}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\pi_{2}(w^{u},w^{d},p)=\begin{cases}
\left(p-w^{u}\right)Q(p) & \mbox{if \ensuremath{w^{u}=w^{d}}}\\
0 & \mbox{otherwise}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
In principle, one should also allow firms an action to refuse any trade
 with the other firm (no matter which 
\begin_inset Formula $w$
\end_inset

 the other firm offers).
 However, we do not have to model such an refusal option explicitly, since
 action profiles with 
\begin_inset Formula $w^{u}=100$
\end_inset

 and 
\begin_inset Formula $p=100$
\end_inset

 have the same effect as if both firm's would refuse to trade, i.e.
 actual payoffs and cheating payoffs of both firms are 
\begin_inset Formula $0$
\end_inset

.
 
\end_layout

\begin_layout Remark
It is clear that for candidates for optimal equilibrium action profiles
 we can restrict attention to the set of profiles where both firms agree
 on a wholesale price or mutually refuse to trade, i.e.
 the set
\begin_inset Formula 
\[
A^{*}=\left\{ (w^{u},w^{d},p)|w^{u}=w^{d}\right\} 
\]

\end_inset

It is also clear that for every discount factor any profile with 
\begin_inset Formula $w^{u}=100$
\end_inset

 and 
\begin_inset Formula $p=100$
\end_inset

 is a Stage game Nash equilibrium and an optimal punishment for both players.
\end_layout

\begin_layout Plain Layout
To analyze the repeated game with this stage game using the pmx-methods
 explained in Section 5.2.
 For using these methods, we have to specify the cheating payoffs of the
 stage game manually.
 We will tell the algorithm only to consider the action profiles contained
 in the set 
\begin_inset Formula $A^{*}$
\end_inset

.
 This makes life bit easier as we only have to specify cheating payoffs
 for all action profiles 
\begin_inset Formula $a\in A^{*}$
\end_inset

.
 We find for the cheating payoffs for firm 1 and 2: 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\pi_{1}^{*}(w^{u},w^{d},p)=\begin{cases}
\mbox{\ensuremath{\max\left\{ \pi_{1}(w^{u},w^{d},p),0\right\} }} & \mbox{if \ensuremath{w^{u}=w^{d}}}\\
\mbox{don't care} & \mbox{otherwise}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\pi_{2}^{*}(w^{u},w^{d},p)=\begin{cases}
\max_{\hat{p}}\left\{ (\hat{p}-w^{u})Q(\hat{p})\right\}  & \mbox{if }\ensuremath{w^{u}=w^{d}}\\
\mbox{don't care} & \mbox{otherwise}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
Where
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\arg\max_{\hat{p}}\left\{ (\hat{p}-w^{u})Q(\hat{p})\right\} =\frac{100+w^{u}}{2}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
One way to tell the algorithm that he only uses action profiles with 
\begin_inset Formula $w^{u}=w^{d}$
\end_inset

 is to provide link functions as explained in the previous Sections.
 The code below uses a simpler approach.
 I simply specify a two dimensional activity space 
\begin_inset Formula $(w^{u},p)$
\end_inset

 and incorporate the actual structure of the true game by the specification
 of the cheating payoffs:
\end_layout

\begin_layout LyX-Code
pmx.init.vert = function() {
\end_layout

\begin_layout LyX-Code
  gx.fun = function(wp) {
\end_layout

\begin_layout LyX-Code
    Q = 100-wp[,2]
\end_layout

\begin_layout LyX-Code
    Q[Q<0]=0
\end_layout

\begin_layout LyX-Code
    g = cbind(Q*wp[,1],Q*(wp[,2]-wp[,1]))
\end_layout

\begin_layout LyX-Code
    return(g)
\end_layout

\begin_layout LyX-Code
  } 
\end_layout

\begin_layout LyX-Code
  cx.fun = function(wp) {
\end_layout

\begin_layout LyX-Code
    # Cheating payoff for downstream firm
\end_layout

\begin_layout LyX-Code
    p.br = ((100+wp[,1])/2) # Best-reply of firm 2
\end_layout

\begin_layout LyX-Code
    c.mat = gx.fun(cbind(wp[,1],p.br)) 
\end_layout

\begin_layout LyX-Code
    # Cheating payoff for upstream firm
\end_layout

\begin_layout LyX-Code
    c.mat[,1] = gx.fun(wp)[,1]
\end_layout

\begin_layout LyX-Code
    # Any firm can guarantee a cheating payoff of 0
\end_layout

\begin_layout LyX-Code
    # by refusing to trade
\end_layout

\begin_layout LyX-Code
    c.mat[c.mat<0]=0
\end_layout

\begin_layout LyX-Code
    return(c.mat)
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  m = pmx.init.game(n=2,nx=2,gx.fun=gx.fun,cx.fun=cx.fun,
\end_layout

\begin_layout LyX-Code
        x.range=c(0,100),name="Model with enforceable w",
\end_layout

\begin_layout LyX-Code
        names.x=c("w","p"))
\end_layout

\begin_layout LyX-Code
  return(m)
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
m = pmx.init.vert()
\end_layout

\begin_layout LyX-Code
cnt = list(step.size.start=1, step.size.end=1)
\end_layout

\begin_layout LyX-Code
m = pmx.solve.model(m,cnt=cnt)
\end_layout

\begin_layout LyX-Code
plot(m,legend.pos="right")
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Plain Layout
In the end, the specification looks very similar to the naive solution discussed
 above.
 The only difference is that the specification of the cheating payoffs for
 the manufacturer accounts for the fact that the manufacturer cannot secretly
 change the wholesale price.
 He can only decide to refuse to trade if 
\begin_inset Formula $w^{u}$
\end_inset

 should be too low, guaranteeing a cheating payoff of 0.
\end_layout

\begin_layout Plain Layout
Let us look at the optimal solution:
\end_layout

\begin_layout LyX-Code
m$pmx.opt
\end_layout

\begin_layout LyX-Code
     delta L   Ue V v1 v2 e.w e.p 1.w 1.p 2.w 2.p   r   UV opt
\end_layout

\begin_layout LyX-Code
[1,]     0 0 2500 0  0  0   0  50   0  50 100 100 Inf 2500   1
\end_layout

\begin_layout Plain Layout
There is a single optimal action plan, which can implement the first best
 for any liquidity, i.e.
 the first best equilibrium action profiles and punishment profiles are
 all Nash equilibria of the stage game.
 The structure of the optimal equilibrium action profile 
\begin_inset Formula $(0,50)$
\end_inset

 is that the wholesale price is equal to the manufacturers marginal costs
 and the retailer sets his monopoly price.
 Since, we allow for side payments, upfront payments work as a kind of fixed
 fee: they allow to transfer profits between the two firms.
\end_layout

\begin_layout Exercise
Adapt the model above by allowing constant marginal production costs 
\begin_inset Formula $MC_{1}$
\end_inset

 and 
\begin_inset Formula $MC_{2}$
\end_inset

 for both firms.
\end_layout

\begin_layout Subsection
Two manufacturers and two downstream firms
\end_layout

\begin_layout Plain Layout
Let us now consider a more interesting set-up with two suppliers and two
 retailers.
 Each supplier 
\begin_inset Formula $s$
\end_inset

 offers each retailer 
\begin_inset Formula $r$
\end_inset

 a constant per unit wholesale price 
\begin_inset Formula $w(s,r)$
\end_inset

.
 We neglect two-part tariffs in this example.
 For simplicity, we assume that retailers must decide on a single supplier.
 Let 
\begin_inset Formula $s(r)$
\end_inset

 denote the exclusive supplier of retailer 
\begin_inset Formula $r$
\end_inset

, where 
\begin_inset Formula $s(r)=0$
\end_inset

 indicates that retailer does not trade.
 Let 
\begin_inset Formula $R(s)$
\end_inset

 denote the set of retailers buying from supplier 
\begin_inset Formula $s$
\end_inset

.
 How an agreement on supply contracts between a retailer and supplier is
 reached is discussed below.
\end_layout

\begin_layout Plain Layout
In this example, we assume that retailers compete in quantities and that
 from perspective of consumers the two manufacturers and the two retailers
 offer homogeneous goods.
 Both retailers choose simultaneously their downstream outputs, denoted
 by 
\begin_inset Formula $q_{1}$
\end_inset

 and 
\begin_inset Formula $q_{2}$
\end_inset

, respectively.
 The inverse market demand function is given by
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
P(Q)=100-Q
\]

\end_inset


\end_layout

\begin_layout Plain Layout
Final stage game profits for upstream and downstream firms are given by
\begin_inset Formula 
\begin{eqnarray*}
\pi_{s} & = & \sum_{r\in R(s)}w(s,r)q_{r}\\
\pi_{r} & = & \left(P(q_{1}+q_{2})-w(s(r),r)\right)q_{r}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Plain Layout
In the moment, I study only two different set-ups:
\end_layout

\begin_layout Enumerate
Full collusion between all firms
\end_layout

\begin_layout Enumerate
Collusion only between upstream firms
\end_layout

\begin_layout Plain Layout
The analysis can in principle be extended to collusion with one or more
 integrated firms, downstream collusion, and of course, one could also consider
 a higher total number of firms or differentiated goods.
\end_layout

\begin_layout Plain Layout
In the simple set-up that I consider, a fully integrated monopolists that
 owns all 4 firms, would choose a downstream price of 50 and make profits
 of 2500, which is thus an upper bound on the collusive profits in any of
 the studied set-up.
 If vertically integrated firms would compete a la Cournot, they would choose
 downstream outputs of 
\begin_inset Formula $\frac{100}{3}$
\end_inset

 each and make joint profits of 
\begin_inset Formula $100*\frac{2}{3}*\frac{1}{3}\thickapprox2222$
\end_inset

.
 Before, we can compare these set-ups, we have to be more precise on the
 form of the stage game.
\end_layout

\begin_layout Paragraph*
Reducing dimensionality of the stage game
\end_layout

\begin_layout Plain Layout
In the ideal stage game, an 
\shape italic
action
\shape default
 of retailer 
\begin_inset Formula $i$
\end_inset

 would be a pair of functions 
\begin_inset Formula $s(w)$
\end_inset

 and 
\begin_inset Formula $q(w)$
\end_inset

 that determine the exclusive supplier and output as functions of the offered
 wholesale prices.
 The problem is that this action space has too many dimensions (e.g.
 if we want to allow wholesale prices and outputs to be chosen from a grid
 of 100 each, the action space would contain 
\begin_inset Formula $(100*100)^{6*100+2}$
\end_inset

 action profiles).
 We therefore simplify the action space.
\end_layout

\begin_layout Plain Layout
We assume that retailers use a monotone rule to decide on their supplier,
 which is characterized by two numbers 
\begin_inset Formula $(h_{r},w_{r}^{0})\in\mathbb{R}^{2}$
\end_inset

 with the following meaning: 
\begin_inset Formula $h_{r}$
\end_inset

 denotes a handicap that the retailer 
\begin_inset Formula $r$
\end_inset

 attaches to firm 2.
 We say the perceived retail price of supplier 1 and 2 for retailer 
\begin_inset Formula $r$
\end_inset

 are 
\begin_inset Formula $w(1,r)$
\end_inset

 and 
\begin_inset Formula $w(2,r)+h_{r}$
\end_inset

.
 A retailer 
\begin_inset Formula $r$
\end_inset

 chooses that supplier who has a strictly lower perceived price.
 If both suppliers have the same perceived price, retailer 3 chooses supplier
 1 and retailer 4 chooses supplier 2.
 The variable 
\begin_inset Formula $w_{r}^{0}$
\end_inset

 denotes a maximum perceived wholesale price for which a retailer is still
 willing to trade if the lowest perceived wholesale price is above 
\begin_inset Formula $w_{r}^{0}$
\end_inset

, we assume that the retailer refuses to trade.
 So we have
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
s(r)=\begin{cases}
1 & \mbox{if \ensuremath{w(1,r)<w(2,r)+h_{r}}}\\
2 & \mbox{if \ensuremath{w(1,r)>w(2,r)+h_{r}}}\\
r & \mbox{if }\ensuremath{w(1,r)=w(2,r)+h_{r}}\\
0 & \mbox{if \ensuremath{\min\{w(1,r),w(2,r)+h_{r}\}>w_{r}^{0}}}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
where the condition in the last row has precedence to those in the earlier
 rows.
\end_layout

\begin_layout Plain Layout
For simplicity, we assume that the output choice is independent from the
 offered wholesale price, i.e.
 the retailers simply choose a fixed output 
\begin_inset Formula $q_{r}\in\mathbb{R}$
\end_inset

.
 The only exception is that if the retailer chooses not to take any supplier,
 i.e.
 
\begin_inset Formula $s(r)=0$
\end_inset

 then its output will be 
\begin_inset Formula $0$
\end_inset

.
\end_layout

\begin_layout Paragraph*
Cheating payoffs for retailers
\end_layout

\begin_layout Plain Layout
Let 
\begin_inset Formula $\hat{w}_{r}=\min_{s}\{w(s,r)\}$
\end_inset

 denote the lowest offered wholesale price for retailer 1.
 The cheating payoff of retailer 1 is given by the maximum of 0 or his Cournot
 best reply payoff given marginal costs 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\hat{w}_{r}$
\end_inset

 and competitors output 
\begin_inset Formula $q_{-r}$
\end_inset

.
\end_layout

\begin_layout Paragraph*
Cheating payoffs for suppliers
\end_layout

\begin_layout Plain Layout
If a supplier does not yet supply any retailer, he always has an incentive
 to marginally undercut the other retailer.
\end_layout

\begin_layout Subsubsection
Full collusion between all upstream and downstream firms
\end_layout

\begin_layout Plain Layout
In Appendix A, you find a somewhat lengthy program that initializes and
 solves the game where all firms can collude with each other.
 In total, using the specification of the stage game above, there is a 12
 dimensional activity space.
 On my computer that is too much to use the deterministic grid refinement
 method, so I use the method that uses stochastic sampling from the global
 grid and local grids around optimal points.
\end_layout

\begin_layout Plain Layout
Do you already know the structure of optimal payoff sets? I only saw it
 after I have run the code and examined the structure of the optimal equilibria
 (of course, the resulting equilibria were not completely optimal, because
 I used the random sampling algorithm, but these almost optimal equilibria
 functioned as an eye opener for the structure of optimal equilibria).
 Perfect collusion with the maximum monopoly profits of 2500 can be sustained
 for every discount factor.
 The structure of an optimal equilibrium that achieves this result is as
 follows: Both manufacturers offer contracts only to a single retailer:
 say retailer 1 at a whole sale price equal to marginal costs, i.e.
 
\begin_inset Formula $0$
\end_inset

.
 That first retailer will then set the optimal monopoly price of 50.
 That no manufacturer makes an offer to the other retailer can be made a
 mutual best reply if the other retailer chooses either output of 0 or a
 level of 
\begin_inset Formula $w_{2}^{0}=0$
\end_inset

: then no manufacturer has an incentive to offer to that retailer and since
 the retailer gets no offer, he also has no incentive to deviate.
 In a similar manner, we can also construct for every supplier and retailer
 optimal punishments that give them a cheating payoff of zero.
 Thus, using monetary transfers, every distribution of the joint equilibrium
 payoff of 2500 can be implemented in an incentive compatible way.
\end_layout

\begin_layout Subsubsection
Upstream collusion
\end_layout

\begin_layout Plain Layout
Let us now consider the case that only upstream firms collude with each
 other.
 To model this, we make the assumption that retailers always buy from the
 cheaper supplier and that their output must be a best-reply given any wholesale
 prices chosen on the equilibrium path and the output of the other retailer.
\end_layout

\begin_layout Plain Layout
Let
\begin_inset Formula $\hat{w}_{r}=\min_{s}\{w(s,r)\}$
\end_inset

 denote the lowest wholesale price offered to retailer 
\begin_inset Formula $r$
\end_inset

.
 Using the standard Cournot formula, we find that the resulting outputs
 of retailers that satisfy the required consistency requirements are given
 by
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
q_{r}^{*}=\frac{100-2\hat{w}_{r}+\hat{w}_{-r}}{3}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
We also have to check that outputs cannot be negative and correspondingly
 adapt outputs.
 My computer code also takes care of this.
 
\end_layout

\begin_layout Plain Layout
To model cheating payoffs of the suppliers, we have to precisely specify
 how retailers adapt their output if some supplier makes an off-the-equilibrium-
path offer of wholesale prices.
 In line with the previous analysis, I assume that retailers cannot adapt
 their outputs after such a deviation: they can only change the chosen supplier
 (or decide not to trade at all).
 So outputs are chosen given rational expectations about equilibrium wholesale
 prices, but not according to truly observed wholesale prices.
 An alternative approach would be that retailers observe wholesale prices
 and can adapt their outputs accordingly, i.e.
 we impose a sequential structure on the stage game.
\end_layout

\begin_layout Plain Layout
I chose the simultaneous move rational expectation approach, since the structure
 of the stage game corresponds more closely to that analyzed in the previous
 subsection and because best-reply functions take a very simple form: since
 an upstream firm does not have to worry about a change in downstream outputs,
 it simply can slightly undercut the prices the other supplier offered to
 both retailers.
 
\end_layout

\begin_layout Plain Layout
To be honest, the actual set-up is technically not covered by our theoretical
 paper, since we do not analyze games with long-run and short-run players.
 However, I don't see any reason why our results should not go through.
 
\end_layout

\begin_layout Plain Layout
An implementation of the code is given in Appendix A.
 Figure ### shows the resulting payoffs:
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../../libraries/repgames/upstream_2sup_2ret.eps
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Joint payoffs of upstream firm under optimal upstream collusion
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Collusion is only possible if 
\begin_inset Formula $\delta\geq\frac{1}{2}$
\end_inset

 and maximal collusive payoffs stay constant for all discount factors above
 this threshold.
 Basically, this outcome is similar to the structure of optimal collusion
 in a simple repeated Bertrand Duopoly.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Subsection
Conjecture about equilibrium payoffs in the repeated oligopoly without monetary
 transfers
\end_layout

\begin_layout Plain Layout
Like some other parts of this paper, this subsection shall illustrate how
 the toolbox can give some help in the development of theoretical results.
 If you are not familiar with our theoretical paper, you really may want
 to skip this subsection, since my intuitive reasoning may seem quite strange.
 (Of course, you may find my reasoning quite strange, even if you are familiar
 with our theoretical paper.) 
\end_layout

\begin_layout Plain Layout
The following code solves the model by allowing only for symmetric action
 profiles in the equilibrium state and both punishment states:
\end_layout

\begin_layout Plain Layout
####
\end_layout

\begin_layout Plain Layout
Consider the following conjecture:
\end_layout

\begin_layout Conjecture
Consider the symmetric oligopoly model were only market prices are observable
 with continuous action and signal space and fix some discount factor 
\begin_inset Formula $\delta$
\end_inset

.
 The following payoff sets coincide:
\end_layout

\begin_layout Enumerate
the set equilibrium payoffs of stationary equilibria with symmetric equilibrium
 and punishment profiles (i.e.
 in every state both firms choose the same output)
\end_layout

\begin_layout Enumerate
the set of PPE payoffs in the repeated game without monetary transfers but
 a public correlation device
\end_layout

\begin_layout Plain Layout
If the conjecture is true, the code above allows us to approximate characterize
 the set of pure strategy equilibrium payoffs in the considered specific
 class of models for the case that no monetary transfers are allowed.
 Again, I do not want to provide a theoretical proof of the conjecture here
 (in fact, I have not yet proven it), but want to illustrate how my toolbox
 and the insights from our theoretical paper can help to get a stronger
 intuition whether the conjecture is likely to be true or false.
\end_layout

\begin_layout Plain Layout
While a direct proof would surely be more direct, we can think of equivalence
 of some intermediate payoff sets.
 First, a variation of the proof of Theorem 1 in our theoretical paper allows
 to establish a general result that every PPE payoff in the game with money
 burning where players are restricted to play symmetric action profiles
 can be implemented with a stationary equilibrium where players only play
 stationary equilibrium profiles.
 
\end_layout

\begin_layout Plain Layout
Second, note that since we restrict attention to perfectly symmetric punishment
 profiles the optimal punishment profiles of all players will be identical
 and the sum of individual punishment payoffs 
\begin_inset Formula $V$
\end_inset

=
\begin_inset Formula $v_{1}+v_{2}$
\end_inset

 will be equal to the minimal possible collective punishment payoff, i.e.
 
\begin_inset Formula $U^{b}=V$
\end_inset

.
 Intuitively, the results in Section 6 of our theoretical paper thus imply
 that the possibility of money burning does not extend the set of equilibrium
 payoffs that do use side payments and a public correlation device, but
 no money burning.
\end_layout

\begin_layout Plain Layout
Third, it is very intuitive that no side-payments are needed under the optimal
 equilibria that do not allow for many burning and are restricted to play
 only symmetric action profiles: since everything is symmetric, there is
 no reason why payments from one player to the other could reduce the incentives
 to deviate.
\end_layout

\begin_layout Plain Layout
Forth, we have to establish that if no side payments would be possible,
 it is optimal to choose symmetric equilibrium and punishment profiles.
 Basically, because of the previous points it must be the case that if it
 is optimal to use these symmetric profiles under the possibility of side
 payments, their use must also be optimal if no side payments are allowed.
 Since observed prices are never informative with respect to which firm
 was more likely to have deviated, it is clear that for the search of optimal
 punishment profiles in the absence of money burning, we can restrict attention
 to punishments that give in expectation the same punishment payoff for
 both players.
 A question, whose solution I do not find directly obvious, is whether the
 lowest expected symmetric punishment payoffs can indeed be achieved by
 playing a symmetric punishment profile or whether perhaps it is better
 to use the public correlation device to randomize between two asymmetric
 punishment profiles in order to achieve the lowest possible expected punishment
 payoffs for both players.
 We can use our toolbox to calculate the minimal joint payoff that can be
 implemented for different action profiles (this can be done at different
 levels of L).
 If it is always weakly lowest for symmetric action profiles, we would have
 a strong indicator that symmetric profiles are indeed the best to minimize
 expected punishment payoffs of both players.
 The following code performs this check at several randomly drawn levels
 of 
\begin_inset Formula $L$
\end_inset

.
 
\end_layout

\begin_layout LyX-Code
#### Add R code here
\end_layout

\begin_layout Plain Layout
The results show that indeed for all chosen levels of 
\begin_inset Formula $L$
\end_inset

, symmetric punishment profiles can achieve the lowest joint payoffs.
\end_layout

\begin_layout Plain Layout
Taking all points, Conjecture ###, is intuitively supported.
 Still, one never knows without a formal proof.
 Nevertheless, I find quite helpful to use my toolbox get some stronger
 feeling about the result is likely to be true or false.
\end_layout

\begin_layout Subsection
Signal dependent auditing probabilities
\end_layout

\begin_layout Plain Layout
If auditing is costly (otherwise, we would essentially have a game of perfect
 monitoring), it may be optimal to adapt the auditing probability to the
 realized signal 
\begin_inset Formula $y$
\end_inset

.
 A clean way to analyze such a set up is to make the choice of auditing
 scheme and contribution to the costs of auditing an explicit decision by
 players in every period.
 
\end_layout

\begin_layout Plain Layout
For example, consider the following extended framework that adds an auditing
 stage in between the action and ex-post payment stages.
 The auditing stage starts with a draw from a public correlation device
 that can be used to determine whether an audit shall take place.
 Then players simultaneously decide whether they agree to be audited and
 each player 
\begin_inset Formula $i$
\end_inset

 can transfer a part of the auditing cost 
\begin_inset Formula $m_{i}$
\end_inset

 to the auditing firm.
 If all players agree to be audited and transferred contributions exceed
 the total auditing costs 
\begin_inset Formula $M$
\end_inset

, an audit takes place and fully reveals the played action profile to all
 players.
\end_layout

\begin_layout Plain Layout
Consider the following class of stationary strategy profiles for this extended
 set-up.
 For each state one specifies a signal dependent auditing probability 
\begin_inset Formula $\pi^{k}(y)$
\end_inset

 and a distribution of auditing costs 
\begin_inset Formula $m_{i}^{k}(y)$
\end_inset

 that satisfies 
\begin_inset Formula $\sum_{i=1}^{n}m_{i}^{k}(y)=M$
\end_inset

.
 If a player rejects to be audited or to pay his share of the auditing cost,
 he must pay his maximum payment 
\begin_inset Formula $\frac{\delta}{1-\delta}(u_{i}-v_{i})$
\end_inset

 in the subsequent payment stage.
 If an audit takes place an detects an unilateral deviation by player 
\begin_inset Formula $i$
\end_inset

, then player 
\begin_inset Formula $i$
\end_inset

 is also asked to pay that maximal payment.
 If no player deviated the payment vector is given by some vector 
\begin_inset Formula $p^{k,a}$
\end_inset

.
 
\end_layout

\begin_layout Plain Layout
Our theoretical paper does not provide an analysis of this extended set-up,
 but I have a strong guess that one can show that also in this set-up one
 can implement every pure PPE strategy payoff by stationary equilibria with
 stick and carrot punishments and that also ....
 
\end_layout

\begin_layout Plain Layout
The new structure shall be as follows: After the signal 
\begin_inset Formula $y$
\end_inset

 has been realized, another public signal is drawn from a uniform distribution.
 If the signal is smaller than a specified auditing probability 
\begin_inset Formula $\pi(y)$
\end_inset

, each player 
\begin_inset Formula $i$
\end_inset

 is asked to pay to pay a share 
\begin_inset Formula $k_{i}(y)$
\end_inset

 of the total auditing costs 
\begin_inset Formula $K$
\end_inset

 and to agree to be audited.
 If some player refuses to make his payment or to be audited, the audit
 does not take place and the player that deviated is required to make the
 maximum payments 
\begin_inset Formula $\frac{\delta}{1-\delta}(u_{i}-v_{i})$
\end_inset

 in the subsequent ex-post payment stage.
 If an audit takes place, the chosen action profile in the action stage
 are fully revealed.
 
\end_layout

\begin_layout Conjecture
If there is the possibility of costly auditing and auditing probabilities
 can optimally depend on the realized signal 
\begin_inset Formula $y$
\end_inset

, there always exist optimal equilibria that do not use money burning.
\end_layout

\begin_layout Proof
Intuition: One can pay for the costly audit instead of burning money.
 A failure to make the required payment will be punished by maximal payments.
 The advantage of paying for the audit instead of burning money is clear:
 if the action profile is fully revealed, any caught person is required
 to make full transfers.
\end_layout

\begin_layout Plain Layout
Idea: Can we simply adapt expected payoffs for auditing costs? There is
 an upper bound on total auditing costs.
 For punishment states, it would be simply given by 
\begin_inset Formula $L$
\end_inset

.
 The problem is that auditing costs on the equilibrium path also reduce
 future payoffs.
 Future payoffs will be simply given by 
\begin_inset Formula $U-\pi K$
\end_inset

.
 How does the opportunity of auditing change the set of future payoffs that
 can be implemented? Consider the static problem.
 Assume every player is asked to pay his liquidity 
\begin_inset Formula $\lambda_{i}L$
\end_inset

 for auditing.
 If he refuses, he will be forced to pay it anyway.
 If a player is caught cheating, he will again be required to pay 
\begin_inset Formula $\lambda_{i}L$
\end_inset

.
 Hence, a player that refuses to be audited did cheat indeed.
 We have to specify the liquidity requirements of implementing a certain
 action profile without money burning given a certain auditing probability:
 
\begin_inset Formula $L(a,\pi)$
\end_inset

.
 We simply consider the static problem with action constraints modified
 as follows:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{equation}
g_{i}(a)-(1-\bar{\pi}(a))\bar{p}_{i}(a)\geq g_{i}(\hat{a}_{i},a_{-i})-(1-\bar{\pi}(\hat{a}_{i},a_{-i}))p_{i}(\hat{a}_{i},a_{-i})-\bar{\pi}(\hat{a}_{i},a_{-i})\lambda_{i}L\label{eq:AC_pi_y}
\end{equation}

\end_inset


\end_layout

\begin_layout Plain Layout
The maximal liquidity that can be generated with a particular action plan
 and auditing plan is given by
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\delta}{1-\delta}\left(G(a^{e})-\bar{\pi}(a^{e})M-V\right)
\]

\end_inset


\end_layout

\begin_layout Plain Layout
We could either make the decision on the auditing plan 
\end_layout

\begin_layout Plain Layout
Action space: Fix the auditing plan.
 Players can only accept or reject the auditing plan (payments will be consequen
tly made).
 Action constraints under rejecting the auditing plan are simply set to
 make maximal payment.
 The signal structure identifies if some player rejects the auditing plan.
 But if he rejects, he will be forced to make maximal payments.
 Thus we need:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{equation}
G(a)-K+L\geq C(a)\label{eq:AC_pi_y}
\end{equation}

\end_inset


\end_layout

\begin_layout Plain Layout
So we need at least a liquidity of
\begin_inset Formula 
\[
L\geq C(a)-G(a)-K
\]

\end_inset


\end_layout

\begin_layout Plain Layout
But that condition can be easily checked.Otherwise, we can simply change
 the program by modifying the action constraints and the fixed point condition
 that combines the static problems in the way explained above.
\end_layout

\begin_layout Plain Layout
Now, we can specify an auditing plan ex-ante and then check which payments
 can be implemented with that auditing plan at some different discount factor.
 One can optimize on optimal auditing plans in an outer optimization problem.
\end_layout

\begin_layout Plain Layout
So the fixed point condition to find the maximal liquidity that can be generated
 mus
\end_layout

\begin_layout Plain Layout
My toolbox allows to condition the signal distribution on the action profile
 that was supposed to be played.
 We can specify the following distribution 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\phi_{a*}(y|a)=
\]

\end_inset


\end_layout

\begin_layout Conjecture
If there is the possibility of costly auditing and auditing probabilities
 can optimally depend on the realized signal 
\begin_inset Formula $y$
\end_inset

, there always exist optimal equilibria that do not use money burning.
\end_layout

\begin_layout Proof
Intuition: One can pay for the costly audit instead of burning money.
 A failure to make the required payment will be punished by maximal payments.
 The advantage of paying for the audit instead of burning money is clear:
 if the action profile is fully revealed, any caught person is required
 to make full transfers.
\end_layout

\begin_layout Exercise
Consider a modification of game from exercise 4.
 Assume with probability 
\begin_inset Formula $\alpha$
\end_inset

 an external audit company verifies the sales of both firms and makes them
 public to both cartel members.
 Formally, with probability 
\begin_inset Formula $\alpha$
\end_inset

 the signal shall reveal the played action profile, while with probability
 
\begin_inset Formula $1-\alpha$
\end_inset

 only the market price is publicly observed.
 Write a function that initializes model.
 Solve the model and investigate the comparative statics w.r.t.
 
\begin_inset Formula $\Delta$
\end_inset

.
 Using the results in our theoretical paper, try to find analytical solutions
 for 
\begin_inset Formula $L(a)$
\end_inset

, 
\begin_inset Formula $U^{e}(L|a)$
\end_inset

 and 
\begin_inset Formula $v_{i}(L|a)$
\end_inset

.
 Assume, each auditing costs a fixed sum 
\begin_inset Formula $k$
\end_inset

 for each firm.
 Fix some 
\begin_inset Formula $\Delta$
\end_inset

 and find the optimal auditing probability 
\begin_inset Formula $\alpha$
\end_inset

 as a function of the discount factor 
\begin_inset Formula $\delta$
\end_inset

.
 (You can use the tools for comparative statics analysis).
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Plain Layout
When the auditing probability is 
\begin_inset Formula $\alpha$
\end_inset

.
 The action constraints in the static problem simply become:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{equation}
g_{i}(a)-(1-\alpha)p_{i}(a)\geq g_{i}(a_{i}\text{′},a_{-i})-(1-\alpha)p_{i}(a_{i}\text{′},a_{-i})-\alpha L\label{eq:AC}
\end{equation}

\end_inset


\end_layout

\begin_layout Plain Layout
because on a detected deviation maximum payments can be imposed.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Section
Appendix B: Code From Longer Examples
\end_layout

\begin_layout Subsection
Full collusion between 2 suppliers and 2 retailers
\end_layout

\begin_layout LyX-Code
################################################################  
\end_layout

\begin_layout LyX-Code
# Full collusion between 2 suppliers and 2 retailers
\end_layout

\begin_layout LyX-Code
################################################################
\end_layout

\begin_layout LyX-Code
pmx.init.2sup.2ret = function(eps.undercut = 0.01) {
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
  nx = 10
\end_layout

\begin_layout LyX-Code
  names.x = c("w1.s1","w1.s2","w2.s1","w2.s2",
\end_layout

\begin_layout LyX-Code
         "q1","q2", "h1","h2","w1.max","w2.max")
\end_layout

\begin_layout LyX-Code
  # We only specify payoffs and cheating payoffs
\end_layout

\begin_layout LyX-Code
  # for action profiles with w.u = w.d
\end_layout

\begin_layout LyX-Code
  get.supplier = function(x) {
\end_layout

\begin_layout LyX-Code
    store.objects("get.supplier")
\end_layout

\begin_layout LyX-Code
    # restore.objects("get.supplier")
\end_layout

\begin_layout LyX-Code
    s = matrix(1,NROW(x),2)
\end_layout

\begin_layout LyX-Code
    # Change to supplier 2 if perceived cheaper
\end_layout

\begin_layout LyX-Code
    s[x[,"w1.s1"] > x[,"w1.s2"]+x[,"h1"] ,1] = 2
\end_layout

\begin_layout LyX-Code
    s[x[,"w2.s1"] >= x[,"w2.s2"]+x[,"h2"],2] = 2
\end_layout

\begin_layout LyX-Code
    # Refuse to be supplied if too expensive
\end_layout

\begin_layout LyX-Code
    w.per = pmin(x[,"w1.s1"],x[,"w1.s2"]+x[,"h1"])
\end_layout

\begin_layout LyX-Code
    s[w.per > x[,"w1.max"],1] = 0
\end_layout

\begin_layout LyX-Code
    w.per = pmin(x[,"w2.s1"],x[,"w2.s2"]+x[,"h2"])
\end_layout

\begin_layout LyX-Code
    s[w.per > x[,"w2.max"],2] = 0
\end_layout

\begin_layout LyX-Code
    return(s)
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
      
\end_layout

\begin_layout LyX-Code
  gx.fun = function(x) {
\end_layout

\begin_layout LyX-Code
    colnames(x) = names.x
\end_layout

\begin_layout LyX-Code
    # Matrix of suppliers for each retailer
\end_layout

\begin_layout LyX-Code
    s = get.supplier(x);
\end_layout

\begin_layout LyX-Code
    return(g.fun.with.s(x,s));
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  # Payoff function with specified suppliers
\end_layout

\begin_layout LyX-Code
  g.fun.with.s = function(x,s) {
\end_layout

\begin_layout LyX-Code
    store.objects("g.fun.with.s")
\end_layout

\begin_layout LyX-Code
    # restore.objects("g.fun.with.s")
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    # Set output to 0 if contract is rejected (s==0)
\end_layout

\begin_layout LyX-Code
    x[s[,1]==0,"q1"] = 0;
\end_layout

\begin_layout LyX-Code
    x[s[,2]==0,"q2"] = 0;
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    # Resulting total output and prices
\end_layout

\begin_layout LyX-Code
    Q = x[,"q1"]+x[,"q2"]
\end_layout

\begin_layout LyX-Code
    P = 100-Q
\end_layout

\begin_layout LyX-Code
    P[P<0]=0
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    # For convenience, we set s=1 if s==0
\end_layout

\begin_layout LyX-Code
    # this does not matter, since we already set q to 0
\end_layout

\begin_layout LyX-Code
    s[s==0] = 1;
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    # Wholesale price of the selected supplier
\end_layout

\begin_layout LyX-Code
    w1 = x[,c("w1.s1","w1.s2")][cbind(1:NROW(x),s[,1])]
\end_layout

\begin_layout LyX-Code
    w2 = x[,c("w2.s1","w2.s2")][cbind(1:NROW(x),s[,2])]
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    # Payoff matrix
\end_layout

\begin_layout LyX-Code
    g = matrix(NA,NROW(x),4)
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    # Profits of retailers
\end_layout

\begin_layout LyX-Code
    g[,3] = (P-w1)*x[,"q1"]
\end_layout

\begin_layout LyX-Code
    g[,4] = (P-w2)*x[,"q2"]
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    # Profits of suppliers
\end_layout

\begin_layout LyX-Code
    g[,1] = w1*x[,"q1"]*(s[,1]==1) +  w2*x[,"q2"]*(s[,2]==1)
\end_layout

\begin_layout LyX-Code
    g[,2] = w1*x[,"q1"]*(s[,1]==2) +  w2*x[,"q2"]*(s[,2]==2)
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    return(g)
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
  # Retailer will choose best reply
\end_layout

\begin_layout LyX-Code
  cx.fun = function(x) {
\end_layout

\begin_layout LyX-Code
    store.objects("cx.fun")
\end_layout

\begin_layout LyX-Code
    # restore.objects("cx.fun")
\end_layout

\begin_layout LyX-Code
    colnames(x) = names.x
\end_layout

\begin_layout LyX-Code
    c.mat = matrix(NA,NROW(x),4)
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    # Just test if everything is correct
\end_layout

\begin_layout LyX-Code
    g.mat = gx.fun(x)
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    ###########################################################
\end_layout

\begin_layout LyX-Code
    # Retailers
\end_layout

\begin_layout LyX-Code
    ###########################################################
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    # Get the cheapest supplier and the resulting wholesale price
\end_layout

\begin_layout LyX-Code
    s = get.supplier(x)
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
    # Set output to 0 if contract is rejected (s==0)
\end_layout

\begin_layout LyX-Code
    x[s[,1]==0,"q1"] = 0;
\end_layout

\begin_layout LyX-Code
    x[s[,2]==0,"q2"] = 0;
\end_layout

\begin_layout LyX-Code
    s1.br = 1+(x[,"w1.s1"]>x[,"w1.s2"])
\end_layout

\begin_layout LyX-Code
    s2.br = 1+(x[,"w2.s1"]>=x[,"w2.s2"])
\end_layout

\begin_layout LyX-Code
    w1.br = pmin(x[,"w1.s1"],x[,"w1.s2"])
\end_layout

\begin_layout LyX-Code
    w2.br = pmin(x[,"w2.s1"],x[,"w2.s2"])
\end_layout

\begin_layout LyX-Code
    #cbind(x,s,s1.br,s2.br,w1.br,w2.br)
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
    # Retailers Cournot Best-Replies
\end_layout

\begin_layout LyX-Code
    q1.br = (100-w1.br)/2 - x[,"q2"]/2
\end_layout

\begin_layout LyX-Code
    q1.br[q1.br<0] = 0
\end_layout

\begin_layout LyX-Code
    q2.br = (100-w2.br)/2 - x[,"q1"]/2
\end_layout

\begin_layout LyX-Code
    q2.br[q2.br<0] = 0
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    cbind(x,s,w1.br,w2.br,q1.br,q2.br)
\end_layout

\begin_layout LyX-Code
        
\end_layout

\begin_layout LyX-Code
    # Calculate cheating payoffs for retailer 1    
\end_layout

\begin_layout LyX-Code
    x.mod = x; x.mod[,"q1"] = q1.br;
\end_layout

\begin_layout LyX-Code
    s.mod = s; s.mod[,1] = s1.br;
\end_layout

\begin_layout LyX-Code
    c.mat[,3] = g.fun.with.s(x.mod,s.mod)[,3]
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    # Calculate cheating payoffs for retailer 2    
\end_layout

\begin_layout LyX-Code
    x.mod = x; x.mod[,"q2"] = q2.br;
\end_layout

\begin_layout LyX-Code
    s.mod = s; s.mod[,2] = s2.br;
\end_layout

\begin_layout LyX-Code
    c.mat[,4] = g.fun.with.s(x.mod,s.mod)[,4]
\end_layout

\begin_layout LyX-Code
    cbind(g.mat[,3],c.mat[,3],g.mat[,4],c.mat[,4])
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    ########################################################
\end_layout

\begin_layout LyX-Code
    # Suppliers
\end_layout

\begin_layout LyX-Code
    ########################################################
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    # Maximum prices a supplier can set to 
\end_layout

\begin_layout LyX-Code
    #obtain a particular retailer
\end_layout

\begin_layout LyX-Code
    # Under indifference retailer r prefers supplier s=r
\end_layout

\begin_layout LyX-Code
    # Negative wholesale prices are never optimal
\end_layout

\begin_layout LyX-Code
    w1.s1.br = pmax(pmin(x[,"w1.s2"]+x[,"h1"],x[,"w1.max"]),0)
\end_layout

\begin_layout LyX-Code
    w2.s1.br = pmax(pmin(x[,"w2.s2"]+x[,"h2"]-eps.undercut,
\end_layout

\begin_layout LyX-Code
               x[,"w2.max"]),0)
\end_layout

\begin_layout LyX-Code
     
\end_layout

\begin_layout LyX-Code
    w1.s2.br = pmax(pmin(x[,"w1.s1"]-x[,"h1"]-eps.undercut,
\end_layout

\begin_layout LyX-Code
                         x[,"w1.max"]-x[,"h1"]),0)
\end_layout

\begin_layout LyX-Code
    w2.s2.br = pmax(pmin(x[,"w2.s1"]-x[,"h2"],
\end_layout

\begin_layout LyX-Code
                    x[,"w2.max"]-x[,"h2"]),0)
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    cbind(x,w1.s1.br,w2.s1.br,w1.s2.br,w2.s2.br)
\end_layout

\begin_layout LyX-Code
    # Calculate cheating payoffs for supplier 1    
\end_layout

\begin_layout LyX-Code
    x.mod = x;
\end_layout

\begin_layout LyX-Code
    x.mod[,"w1.s1"] = w1.s1.br; x.mod[,"w2.s1"] = w2.s1.br;
\end_layout

\begin_layout LyX-Code
    s.mod = matrix(1,NROW(x),2)
\end_layout

\begin_layout LyX-Code
    c.mat[,1] = g.fun.with.s(x.mod,s.mod)[,1]
\end_layout

\begin_layout LyX-Code
    cbind(x,s,x.mod,s.mod)
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    # Calculate cheating payoffs for supplier 2   
\end_layout

\begin_layout LyX-Code
    x.mod = x;
\end_layout

\begin_layout LyX-Code
    x.mod[,"w1.s2"] = w1.s2.br; x.mod[,"w2.s2"] = w2.s2.br;
\end_layout

\begin_layout LyX-Code
    s.mod = matrix(2,NROW(x),2)
\end_layout

\begin_layout LyX-Code
    c.mat[,2] = g.fun.with.s(x.mod,s.mod)[,2]
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    cbind(g.mat[,1],c.mat[,1],g.mat[,2],c.mat[,2],
\end_layout

\begin_layout LyX-Code
          g.mat[,3],c.mat[,3],g.mat[,4],c.mat[,4])
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    # Just test that helped to find mistakes
\end_layout

\begin_layout LyX-Code
    # during the debugging stage
\end_layout

\begin_layout LyX-Code
    if (sum((c.mat-g.mat)<0)>0) {
\end_layout

\begin_layout LyX-Code
      stop("Error: Cheating payoffs are smaller than payoffs!")
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    return(c.mat)
\end_layout

\begin_layout LyX-Code
  }    
\end_layout

\begin_layout LyX-Code
  x.range = matrix(0,10,2)
\end_layout

\begin_layout LyX-Code
  x.range[,2] = 100
\end_layout

\begin_layout LyX-Code
  rownames(x.range) = names.x
\end_layout

\begin_layout LyX-Code
  x.range["h1",1] = -100
\end_layout

\begin_layout LyX-Code
  x.range["h2",1] = -100
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
  m = pmx.init.game(n=4,nx=10,gx.fun=gx.fun,cx.fun=cx.fun,
\end_layout

\begin_layout LyX-Code
        x.range=x.range,
\end_layout

\begin_layout LyX-Code
        name="2 Suppliers 2 Retailers", names.x=names.x)
\end_layout

\begin_layout LyX-Code
  return(m)
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
# Init, solve and plot the model
\end_layout

\begin_layout LyX-Code
m = pmx.init.2sup.2ret()
\end_layout

\begin_layout LyX-Code
# Use random sampling method
\end_layout

\begin_layout LyX-Code
cnt = list(random = TRUE, x.step=1, abs.dist=5,
\end_layout

\begin_layout LyX-Code
           size.draw = 500,num.draws = 500)
\end_layout

\begin_layout LyX-Code
m = pmx.solve.model(m,cnt=cnt) # Use default parameters for solution
\end_layout

\begin_layout LyX-Code
plot(m,legend.pos="right")
\end_layout

\begin_layout LyX-Code
m$pmx.opt.mat
\end_layout

\begin_layout Subsection
Upstream collusion in the model with 2 suppliers and 2 retailers
\end_layout

\begin_layout LyX-Code
#######################################################################
  
\end_layout

\begin_layout LyX-Code
# Upstream collusion between 2 suppliers and 2 retailers
\end_layout

\begin_layout LyX-Code
#######################################################################
\end_layout

\begin_layout LyX-Code
get.q.from.w = function(w1,w2) {
\end_layout

\begin_layout LyX-Code
  # Cournot equilibrium output and prices
\end_layout

\begin_layout LyX-Code
  q1 = (100-2*w1+w2) / 3
\end_layout

\begin_layout LyX-Code
  q2 = (100-2*w2+w1) / 3
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
  # Adapt for non-negativity
\end_layout

\begin_layout LyX-Code
  q1.neg = which(q1<0)
\end_layout

\begin_layout LyX-Code
  q1[q1.neg] = 0
\end_layout

\begin_layout LyX-Code
  q2[q1.neg] = (100-w2[q1.neg])/2 
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
  q2.neg = which(q2<0)
\end_layout

\begin_layout LyX-Code
  q2[q2.neg] = 0
\end_layout

\begin_layout LyX-Code
  q1[q2.neg] = (100-w1[q2.neg])/2 
\end_layout

\begin_layout LyX-Code
  return(cbind(q1,q2))
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
init.upstream.collusion = function() {
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
  nx = 10
\end_layout

\begin_layout LyX-Code
  names.x = c("w1.s1","w1.s2","w2.s1","w2.s2")
\end_layout

\begin_layout LyX-Code
  # We only specify payoffs and cheating payoffs
\end_layout

\begin_layout LyX-Code
  # for action profiles with w.u = w.d
\end_layout

\begin_layout LyX-Code
  get.supplier = function(x) {
\end_layout

\begin_layout LyX-Code
    store.objects("get.supplier")
\end_layout

\begin_layout LyX-Code
    # restore.objects("get.supplier")
\end_layout

\begin_layout LyX-Code
    s = matrix(1,NROW(x),2)
\end_layout

\begin_layout LyX-Code
    # Change to supplier 2 if cheaper
\end_layout

\begin_layout LyX-Code
    s[x[,"w1.s1"] > x[,"w1.s2"] ,1] = 2
\end_layout

\begin_layout LyX-Code
    s[x[,"w2.s1"] >= x[,"w2.s2"],2] = 2
\end_layout

\begin_layout LyX-Code
    return(s)
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
  gx.fun = function(x) {
\end_layout

\begin_layout LyX-Code
    colnames(x) = names.x
\end_layout

\begin_layout LyX-Code
    # Matrix of suppliers for each retailer
\end_layout

\begin_layout LyX-Code
    s = get.supplier(x);
\end_layout

\begin_layout LyX-Code
    return(g.fun.with.s(x,s));
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  # Payoff function with specified suppliers
\end_layout

\begin_layout LyX-Code
  g.fun.with.s = function(x,s) {
\end_layout

\begin_layout LyX-Code
    store.objects("g.fun.with.s")
\end_layout

\begin_layout LyX-Code
    # restore.objects("g.fun.with.s")
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    # Wholesale price of the selected supplier
\end_layout

\begin_layout LyX-Code
    w1 = x[,c("w1.s1","w1.s2")][cbind(1:NROW(x),s[,1])]
\end_layout

\begin_layout LyX-Code
    w2 = x[,c("w2.s1","w2.s2")][cbind(1:NROW(x),s[,2])]
\end_layout

\begin_layout LyX-Code
     
\end_layout

\begin_layout LyX-Code
    q = get.q.from.w(w1,w2)
\end_layout

\begin_layout LyX-Code
    q1 = q[,1]; q2 = q[,2]
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
    # Payoff matrix
\end_layout

\begin_layout LyX-Code
    g = matrix(NA,NROW(x),2)
\end_layout

\begin_layout LyX-Code
        
\end_layout

\begin_layout LyX-Code
    # Profits of suppliers
\end_layout

\begin_layout LyX-Code
    g[,1] = w1*q1*(s[,1]==1) +  w2*q2*(s[,2]==1)
\end_layout

\begin_layout LyX-Code
    g[,2] = w1*q1*(s[,1]==2) +  w2*q2*(s[,2]==2)
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    return(g)
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
  cx.fun = function(x) {
\end_layout

\begin_layout LyX-Code
    store.objects("cx.fun")
\end_layout

\begin_layout LyX-Code
    # restore.objects("cx.fun")
\end_layout

\begin_layout LyX-Code
    colnames(x) = names.x
\end_layout

\begin_layout LyX-Code
    c.mat = matrix(NA,NROW(x),2)
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    # Just to test that everything is correct
\end_layout

\begin_layout LyX-Code
    g.mat = gx.fun(x)
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    ################################################################
\end_layout

\begin_layout LyX-Code
    # Retailers
\end_layout

\begin_layout LyX-Code
    ################################################################
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    # Get the cheapest supplier and the resulting wholesale price
\end_layout

\begin_layout LyX-Code
    s = get.supplier(x)
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    # Wholesale price of the selected supplier
\end_layout

\begin_layout LyX-Code
    w1 = x[,c("w1.s1","w1.s2")][cbind(1:NROW(x),s[,1])]
\end_layout

\begin_layout LyX-Code
    w2 = x[,c("w2.s1","w2.s2")][cbind(1:NROW(x),s[,2])]
\end_layout

\begin_layout LyX-Code
      
\end_layout

\begin_layout LyX-Code
    q = get.q.from.w(w1,w2)
\end_layout

\begin_layout LyX-Code
    q1 = q[,1]; q2 = q[,2]
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    P = 100-q1-q2
\end_layout

\begin_layout LyX-Code
    # Maximum prices a supplier can set to obtain a particular retailer
\end_layout

\begin_layout LyX-Code
    # Under indifference retailer r prefers supplier s=r
\end_layout

\begin_layout LyX-Code
    # Negative wholesale prices are never optimal
\end_layout

\begin_layout LyX-Code
    w1.br = pmin(x[,"w1.s1"],x[,"w1.s2"])
\end_layout

\begin_layout LyX-Code
    w2.br = pmin(x[,"w2.s1"],x[,"w2.s2"])     
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    # Account for the fact that the retailer would reject 
\end_layout

\begin_layout LyX-Code
    # if wholesale price are above the market price
\end_layout

\begin_layout LyX-Code
    w1.br = pmin(w1.br, P)
\end_layout

\begin_layout LyX-Code
    w2.br = pmin(w2.br, P)
\end_layout

\begin_layout LyX-Code
    # Cheating payoffs of suppliers
\end_layout

\begin_layout LyX-Code
    c.mat[,1] = w1.br*q1 + w2.br*q2
\end_layout

\begin_layout LyX-Code
    c.mat[,2] = c.mat[,1]
\end_layout

\begin_layout LyX-Code
    cbind(x,s,q1,q2,w1.br,w2.br,c.mat,g.mat)
\end_layout

\begin_layout LyX-Code
    if (sum((c.mat-g.mat)<0)>0) {
\end_layout

\begin_layout LyX-Code
      ERROR.RET <<- list(c.mat=c.mat,g.mat=g.mat, x.mat = x)
\end_layout

\begin_layout LyX-Code
      stop("Error: Cheating payoffs are smaller than payoffs! Results stored
 in ERROR.RET")
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    return(c.mat)
\end_layout

\begin_layout LyX-Code
  }    
\end_layout

\begin_layout LyX-Code
  m = pmx.init.game(n=2,nx=4,gx.fun=gx.fun,cx.fun=cx.fun, x.range=c(0,100),
\end_layout

\begin_layout LyX-Code
        name="2 Suppliers 2 Retailers", names.x=names.x)
\end_layout

\begin_layout LyX-Code
  return(m)
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
# Init, solve and plot the model
\end_layout

\begin_layout LyX-Code
m = init.upstream.collusion()
\end_layout

\begin_layout LyX-Code
# Grid refinement method with random start points
\end_layout

\begin_layout LyX-Code
cnt = list(use.random.start.points = TRUE,step.size.start=1, 
\end_layout

\begin_layout LyX-Code
           step.size.end=1, grid.size = 50000)
\end_layout

\begin_layout LyX-Code
# Random sampling method
\end_layout

\begin_layout LyX-Code
cnt = list(random = TRUE, step.size=1, abs.dist=5,
\end_layout

\begin_layout LyX-Code
           size.draw = 500,num.draws = 150)
\end_layout

\begin_layout LyX-Code
m = pmx.solve.model(m,cnt=cnt) # Use default parameters for solution
\end_layout

\begin_layout LyX-Code
plot(m,legend.pos="right")
\end_layout

\begin_layout LyX-Code

\end_layout

\end_inset


\end_layout

\end_body
\end_document
